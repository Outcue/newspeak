Newspeak3
'OrthogonalSynchronization'
class ClientSynchronization usingPlatform: platform clientServer: clientServerModule = (
|
	private Smalltalk = 	platform squeak Smalltalk.
	WeakIdentityKeyMap = platform squeak WeakIdentityKeyDictionary.
	Map = platform collections Map.
	Set = platform collections Set.
	IdentitySet = platform collections IdentitySet.
		
	ObjectMirror = platform mirrors ObjectMirror.
	clientServerSync = clientServerModule.
|
) (
class ChangeAnalyzerResult newIds: newIdsMap changeLog: aChangeLogForServer = (
|
	public newObjectToLocalIds = newIdsMap.
	public changeLog = aChangeLogForServer.
	
|
) (
public hasNoChanges = (
	^ changeLog hasNoChanges.
)
) : (
)
public class ChangeTrackingContext = (
|
	guidByObject = WeakIdentityKeyMap new.
	stateByObject = WeakIdentityKeyMap new.
|
) (
class ChangeAnalyzer = (
|
	newObjectsIds
|
) (
changesForExistingObjects = (
	^ Array streamContents: [:stm |
		existingObjectAndStateDo: [:object :state |
			createChangeRecordFor: object
			 withState: state
			 ifNeeded:  [:changeRecord | stm nextPut: changeRecord] .
		].
	].	
)
computeNewObjectDefinitionsDo: definitionsAndIdsMapBlock  = (
	| objectToLocalIdMap newDefinitions |
	objectToLocalIdMap:: Map new.

	newDefinitions:: Array streamContents: [:stm |
		newObjectsIds keysDo: [ :newObject  |

			| definitionWithId |
			definitionWithId::  (createObjectDefinitionWithIdFor: newObject).
			objectToLocalIdMap at: newObject put: definitionWithId id.
			stm nextPut: definitionWithId.
		].
	].	

	definitionsAndIdsMapBlock value: newDefinitions value: objectToLocalIdMap.
)
context  = (
	^ (ObjectMirror reflecting: self) getClass enclosingObject reflectee
)
createChangeRecordFor: anObject withState: initialState ifNeeded: newChangeRecordBlock = (	

	anObject isArray 
					ifTrue:  [ createChangeRecordForArray: anObject withState: initialState ifNeeded: newChangeRecordBlock]
					ifFalse: [ createChangeRecordForRegularObject: anObject withState: initialState ifNeeded: newChangeRecordBlock ].
	
)
createChangeRecordForArray: anObject withState: initialState ifNeeded: newChangeRecordBlock    = (
	| changesByIndex  |

	changesByIndex:: Map new.
	1 to: anObject size do:  [ :index |
		| content reference |
		content:: anObject at: index.
		reference:: initialState at: index.
		(reference refersTo: content inContext: context) ifFalse: 
			[ changesByIndex at: index put:  (toObjectReference: content)   ].
	].


	changesByIndex isEmpty 
		ifFalse:  [ 
				| ch |
				ch:: ArrayChange withChanges: changesByIndex.
				newChangeRecordBlock value: ( ObjectChangeRecord 
													for: (toExistingObjectReference: anObject) 
													withChange: ch).
													]. 


)
createChangeRecordForRegularObject: anObject withState: initialState ifNeeded: newChangeRecordBlock  = (
	| changesBySlot mirror |
	mirror:: ObjectMirror reflecting: anObject.	
	changesBySlot:: Map new.
	initialState keysAndValuesDo: [ :selector :val |
		| slotContent |
		slotContent:: (mirror getSlot: selector) reflectee. 
		(val refersTo: slotContent inContext:  context) ifFalse: [ 
			changesBySlot at: selector put:  (toObjectReference: slotContent)  
		].
	].


	changesBySlot isEmpty 
		ifFalse:  [ 	
				| ch |
				ch:: RegularObjectChange withChanges: changesBySlot.
				
				newChangeRecordBlock value: (ObjectChangeRecord 
													for: (toExistingObjectReference: anObject) 
													withChange: ch). ] 

	 
)
createObjectDefinitionFor: anObject   = (	

		^ anObject isArray 
					ifTrue:  [ createObjectDefinitionForArray: anObject ]
					ifFalse: [ createObjectDefinitionForRegularObject: anObject ].

)
createObjectDefinitionForArray: anObject   = (	
	|  values  |
	values:: createObjectStateFor: anObject.
	^ ArrayDefinition withContents: values.
)
createObjectDefinitionForRegularObject: anObject   = (	
	|  enclosingObject valuesBySlot  classReference   |
	
	valuesBySlot:: createObjectStateFor: anObject.
	enclosingObject:: clientServerSync enclosingObjectForClassOf: anObject.
	 
	classReference:: ObjectReferenceByMessageSend receiverReference: (toObjectReference: enclosingObject) selector: (clientServerSync classNameFor: anObject).
	
	^ ObjectDefinition 
		classReference: classReference 
		withContents: valuesBySlot.
		

)
createObjectDefinitionWithIdFor: anObject   = (	
	|     newId   |
	newId:: newObjectsIds at: anObject.
	^ ObjectDefinitionWithIdentification id: newId definition: (createObjectDefinitionFor: anObject).  
)
createObjectStateFor: anObject  = (
	^ createObjectState: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ]
)
discoverNewObjects = (
	traverseObjectsGraph: newObjectsIds keys visited: (Set withAll:  existingObjects)  do: [ :each |
		(isNew: each) ifTrue: [
			registerIdForNewObjectIfNeeded: each.
		].
	].
)
idForNewObject: anObject  = (
	registerIdForNewObjectIfNeeded: anObject.
	^ newObjectsIds at: anObject.
)
newObjectReferenceFor: anObject = (
	^ toNewObjectReferenceIdentifiedWith: (idForNewObject: anObject).
)
registerIdForNewObjectIfNeeded: anObject  = (
	| newId  existingIds |
	newId:: 1.
	existingIds:: newObjectsIds values.
	existingIds isEmpty ifFalse: [
		newId:: existingIds max + 1.
	].	
	
	^ newObjectsIds at: anObject ifAbsentPut: [ newId ].
)
toObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [ :obj | newObjectReferenceFor: obj ] .	
)
traverseObjectsGraph: elements do: aBlock = (	
	traverseObjectsGraph: elements visited: IdentitySet new do: aBlock. 
)
traverseObjectsGraph: elements visited: visitedObjects do: aBlock = (
	(elements select: [:x | isIdentifiable: x]) do: [ :each |
		(visitedObjects includes: each) ifFalse: [
			visitedObjects add: each.
			aBlock value:  each. 
			slotsIn: each do: [:selector :content | 	
				(* discovered: content.  *)
	 			traverseObjectsGraph: {content} visited: visitedObjects do: aBlock.		
			].
			
		].	
	].
)
public value  = (
	| detectedChanges  changeLog   |
	
	newObjectsIds:: Map new.

	detectedChanges:: changesForExistingObjects.
	discoverNewObjects. 
	computeNewObjectDefinitionsDo:
	 [ 
		:newObjectDefinitions :newObjectToLocalMap |
		changeLog:: ClientToServerChangeLog 
						withChanges: detectedChanges 
						withNewObjects: newObjectDefinitions.
						
		^ ChangeAnalyzerResult newIds: newObjectToLocalMap changeLog: changeLog. ].
)
) : (
)
class ObjectState className: aClassName enclosing: anEnclosingObject  contents: contents  = (
|
	public className = aClassName.
	public slotContents = contents.
	public enclosingObject = enclosingObject.
|
) (
) : (
)
createArrayState: anArray = (
	^createArrayState: anArray  newObjectFrom: nil.
)
createArrayState: anArray  newObjectFrom: newObjectBlock = (
	^ (anArray collect: 
		 [ :each |  toObjectReference: each  newObjectFrom: newObjectBlock  ]) asArray.
)
createObjectState: anObject  = (
	^ createObjectState: anObject newObjectFrom: nil.
)
createObjectState: anObject newObjectFrom: newObjectBlock  = (
	
	anObject isArray ifTrue: 
		[ ^ createArrayState: anObject newObjectFrom: newObjectBlock ].
	
	^ createRegularObjectState: anObject newObjectFrom: newObjectBlock
)
createRegularObjectState: anObject newObjectFrom: newObjectBlock = (
	|  valuesBySelector objectMirror  enclosingObjectReference |
	valuesBySelector:: Map new.
	
	slotsIn: anObject do:  [ :selector :content |
		| objectReference |
		objectReference:: toObjectReference: content newObjectFrom: newObjectBlock .
		valuesBySelector at: selector put: objectReference.
	].

(*	enclosingObjectReference:: toObjectReference: (enclosingObjectForClassOf: anObject)  newObjectFrom: newObjectBlock.
	^ ObjectState
			 className: (classNameFor: anObject) 
			enclosing: enclosingObjectReference  
			contents: valuesBySelector.
			
	*)
	^ valuesBySelector		
			
)
public detectChanges = (
	garbageCollect. 
	^ ChangeAnalyzer new value.
)
existingObjectAndStateDo: aBlock = (
	stateByObject keysAndValuesDo: aBlock.
)
public existingObjects  = (
	^ guidByObject keys	
)
guidFor: anObject  = (
	^ guidByObject at: anObject.
)
public idForObject: anObject  = (
	^ guidByObject at: anObject.
)
public installNewObjectsFromIObjectToIdsMap: anIdsMap = (
	| allObjects |
		
	allObjects:: anIdsMap keys.
	allObjects do: [:each | guidByObject at: each put: (anIdsMap at: each) ].
	allObjects do: [:each | saveObjectState: each. ].
)
public isIdentifiable: anObject  = (
	^ ({ #isKindOfInteger . #isKindOfString  . #isNil  } 
		anySatisfy:  [:selector | anObject perform:  selector ] ) not

)
isNew: anObject = (
	^ (isIdentifiable: anObject) and:
		[ (guidByObject includesKey: anObject) not ].
)
public isTracked: anObject = (
	^ guidByObject includesKey: anObject.
)
public isTrackingObjectWithId: anId  = (
	objectById: anId ifNotFound: [ ^ false].
	^ true.
)
public objectById: anIdentifier = (
	^  objectById: anIdentifier ifNotFound: [ error].
)
public objectById: anIdentifier ifNotFound: notFoundBlock = (
	guidByObject keysAndValuesDo: [ :object :id | 
		(id = anIdentifier) ifTrue: [ ^ object].
	].

	^ notFoundBlock value.	
)
public objectWithGuid: anIdentifier = (
	^  objectById: anIdentifier.
)
public objectsDo: aBlock = (
	guidByObject keys do: aBlock.
)
saveObjectState: anObject  = (
	stateByObject at: anObject put: (createObjectState: anObject).
)
slotsIn: anObject do: selectorAndContentBlock = (
	| mirror valuesBySelector |
	mirror:: ObjectMirror reflecting: anObject.
	
	mirror getClass slots do:  [ :each |
		| selector  object|
		selector:: each name.
		object:: (mirror getSlot: selector) reflectee.
		selectorAndContentBlock value: selector value: object.
	].
)
toExistingObjectReference: anObject = (
	^ toObjectReference: anObject newObjectFrom: [:x | error]. 
)
toNewObjectReferenceIdentifiedWith: id  = (
	^  NewObjectReference toObjectIdentifiedWith: id.
)
toObjectReference: anObject newObjectFrom: newObjectBlock = (
	^ (isIdentifiable:  anObject) 
		ifTrue: [ 
			(isNew: anObject) 
				ifTrue: [ newObjectBlock value: anObject ]
				ifFalse: [ ObjectReference toObjectIdentifiedWith: (guidFor: anObject) ].
		]
		ifFalse: [ UnidentifiableObject for: anObject ].
)
public updateStateForObjectsWithId: ids =  (

	ids do: [ :each | saveObjectState: (objectById: each)  ].
)
public valuesForObject: anObject  = (
	^ stateByObject at: anObject.
)
) : (
)
public class ClientUpdater materializingObjectsWith: aMaterializerFactory forContext: cto endPoint: anEndPoint= (
|
	changeTrackingContext = cto.
	endPoint = anEndPoint.
	materializerFactory = aMaterializerFactory.
|
) (
applyChangesFrom:  changeRecords in: aStore = (
	changeRecords do: [ :each | each applyChangesIn: aStore usingMirror: ObjectMirror ].   
)
applyClientChangesFrom:  changeRecords in: aStore = (
	
	| storeVersion |
	storeVersion:: changeTrackingContext. 
	
	changeRecords do: [ :each | 
		| globalChangeRecord  previousVersion   |
		
		globalChangeRecord:: each asGlobalReferenceUsing: aStore. 
		previousVersion:: storeVersion parentVersion versionById: globalChangeRecord objectReference identifier.
		 storeVersion addObjectVersionWithParent: previousVersion versionedData: globalChangeRecord change.

	].   
)
createStoreForGlobalNewObjects = (
	^ ObjectStoreWithGlobalNewObjects forContext: changeTrackingContext.
)
createStoreForLocalNewObjects = (
	^ ObjectStoreWithLocalNewObjects forStoreVersion: changeTrackingContext newGuidBlock: [ endPoint generateNextGuid ].
)
installLocalObjectsWithGuidUsing: clientChangesResult mappingGlobalsWith: serverToClientChangeLog  = (
	| objectToIdMap | 

	objectToIdMap:: Map new.
	clientChangesResult ifNotNil: [
		clientChangesResult newObjectToLocalIds keysAndValuesDo: [ :object :localId |
			  (serverToClientChangeLog  localToGlobalIds includesKey: localId) 
				ifTrue:  [ objectToIdMap at: object put: (serverToClientChangeLog  localToGlobalIds at: localId)   ].
		].
	].
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: objectToIdMap.
)
installNewObjectsFromDefinitions:  objectDefinitionsWithId usingStore: aStore  = (
	| materializer |
	materializer:: materializerFactory value: aStore. 
	materializer materializeObjectsFrom: objectDefinitionsWithId.
	 (* aStore registerNewObjects. *)
)
public updateFrom: clientChangesResult to: serverToClientChangeLog  = (
	| store |

	installLocalObjectsWithGuidUsing: clientChangesResult mappingGlobalsWith: serverToClientChangeLog.

	store:: createStoreForGlobalNewObjects.
	installNewObjectsFromDefinitions: serverToClientChangeLog newObjects usingStore: store. 
	applyChangesFrom:  serverToClientChangeLog changeRecords in: store.  
	store registerNewObjects.
	
	clientChangesResult ifNotNil: [
	
	store updateStateForObjectsWithId: ( clientChangesResult changeLog changeRecords collect: [ :x | x objectReference identifier] ).
].
	^ serverToClientChangeLog rootObjectReference referencedObjectFrom: store.
	
	
)
public updateServerFrom: clientToServerChangeLog = (
	| store  |

	store:: createStoreForLocalNewObjects.
	installNewObjectsFromDefinitions: clientToServerChangeLog newObjectsDefinitions usingStore: store. 
	store registerNewObjects.
	applyClientChangesFrom:  clientToServerChangeLog changeRecords in: store.  
	^ store localToGuidMap
	
)
) : (
)
class DefinitionsToObjectsMaterializer objectStore: aStore manifest: aManifest  = ObjectsMaterializer objectStore: aStore (
|
	manifest = aManifest.
|
) (
createInstanceFrom: definitionWithId = (
	| newInstance klass |

	klass:: nil.

	definitionWithId definition isKindOfObjectDefinition ifTrue: [
		klass:: (definitionWithId definition classReference referencedObjectFrom: objectStore topLevel: manifest) reflectee.
	].


	newInstance:: definitionWithId definition createEmptyInstanceUsingClass: klass.
	 ^  newInstance
)
fillNewInstance: anInstance fromDefinition: aDefinition = (
	| newInstanceMirror |

	newInstanceMirror:: ObjectMirror reflecting: anInstance.
	aDefinition  fill: newInstanceMirror resolvingReferencesWith: objectStore.
)
) : (
)
class ObjectStoreWithGlobalNewObjects forContext: aTrackingContext  = TransientObjectStore  (
|
	changeTrackingContext = aTrackingContext.
	newObjectsByGuid = Map new.
|
) (
public containsNewObjectWithId: anId  = (
	^  newObjectsByGuid includesKey: anId.
)
public containsObjectWithGuid: anIdentifier = (
	changeTrackingContext objectById: anIdentifier ifNotFound: [
		^ newObjectsByGuid includesKey: anIdentifier.
	].

	^ true 
)
public newObjectWithId: anId  = (
	^  newObjectsByGuid at: anId.

)
public objectWithGuid: anIdentifier = (
	^ changeTrackingContext objectById: anIdentifier ifNotFound: [
		newObjectsByGuid at: anIdentifier.
	]. 
)
public registerNewObjects = (
	changeTrackingContext installNewObjectsFromIObjectToIdsMap: (reverseLookup: newObjectsByGuid). 
)
public registerObject: anObject identifiedWith: id = (
 	newObjectsByGuid at: id put: anObject.
)
public updateStateForObjectsWithId: ids = (
	changeTrackingContext updateStateForObjectsWithId: ids.
)
) : (
)
class ObjectStoreWithLocalNewObjects forStoreVersion: aStoreVersion newGuidBlock: aNewGuidBlock = TransientObjectStore  (
|
	storeVersion = aStoreVersion.
	newObjectsByLocal = Map new.
	newGuidBlock = aNewGuidBlock.
|
) (
public containsNewObjectWithId: anId  = (
	^ newObjectsByLocal includesKey: anId.

)
public containsObjectWithGuid: anIdentifier = (
	storeVersion objectById: anIdentifier ifNotFound: [
		^ false.
	].
	^true 
)
public guidForLocal: aLocalId = (
	^ (newObjectsByLocal at: aLocalId) principalId.
	(* ^ localToGuidMap at: aLocalId. *)
)
public localToGuidMap = (
	| newMap |
	newMap:: Map new.
	newObjectsByLocal keysAndValuesDo: [ :localId :object | newMap at: localId put: object principalId   ].	

	^ newMap
)
public newGuid = (
	^ newGuidBlock value.
)
public newObjectWithId: anId  = (
	^  newObjectsByLocal at: anId.

)
public objectWithGuid: anIdentifier = (
	^ storeVersion versionById: anIdentifier .
)
public registerNewObjects = (

	newObjectsByLocal values do: [ :object  | storeVersion addObjectVersion:  object .  ].
	
)
public registerObject: anObject identifiedWith: id = (
 	newObjectsByLocal at: id put: anObject.
)
) : (
)
public class ObjectsMaterializer objectStore: anObjectStore = (
|
	objectStore = anObjectStore.
|
) (
createInstanceFrom:   definitionWithId = (
	subclassResponsibility.

)
fillNewInstance: anInstance fromDefinition: aDefinition = (
	subclassResponsibility.
)
public materializeObjectsFrom: definitionsWithId = (
	|  newInstances |

	(* ensure every new object  gets instantiated (empty) but with an id *)
	definitionsWithId do: [:each | registerIfNeededObjectWithId:  each id usingDefinitions: definitionsWithId ].
	
	newInstances::	definitionsWithId collect: [:each | 
			| newInstance  |
			newInstance:: objectStore newObjectWithId: each id .  
			fillNewInstance: newInstance fromDefinition: each definition.
	].

	^ newInstances.	
)
registerIfNeededObjectWithId: anId usingDefinitions: definitions = (

	(objectStore containsNewObjectWithId: anId) ifFalse: [
		| definitionWithId definition newInstance isEnclosingNew |
		definitionWithId:: definitions detect: [:each | each id = anId  ].
		definition:: definitionWithId definition.
		

		definition isKindOfObjectDefinition ifTrue: [	
			
(*			(definition classReference receiverReference existsReferencedObjectIn:   objectStore) ifFalse: [    
				registerIfNeededObjectWithId: definition classReference receiverReference identifier  usingDefinitions: definitions.
			].
*)

			(definition classReference existsReferencedObjectIn:   objectStore) ifFalse: [    
				registerIfNeededObjectWithId: definition classReference receiverReference identifier  usingDefinitions: definitions.
			].
		
		
		
		].
	
		
		definition isKindOfArrayDefinition ifTrue: [	 
			
		].
	
	
	
		newInstance:: createInstanceFrom: definitionWithId. 
		objectStore registerObject: newInstance identifiedWith: definitionWithId id.	
	
	].
)
) : (
)
public class StoreClient manifest: aManifest  = (
|
	public cto = ChangeTrackingContext new.
	public currentVersion ::= 0.
	manifest = aManifest.
	public root
|
) (
createClientUpdater = (
	^ ClientUpdater materializingObjectsWith: [ :aStore |  DefinitionsToObjectsMaterializer objectStore: aStore manifest: manifest  ] forContext: cto endPoint: nil.
)
public hasPendingChanges = (
	^ cto detectChanges hasNoChanges not.
)
public idForObject: anObject = (
	^ cto idForObject: anObject
)
public isTracked: anObject = (
	^ cto isTracked: anObject
)
public objectById: anId = (
	 ^ cto objectById: anId.
)
resetTransientSlots = (
	cto objectsDo: [ :anObject |
		| objectMirror| 
		objectMirror:: ObjectMirror reflecting: anObject.
		objectMirror getClass transientSlots do: [ :aSlot | objectMirror setTransientSlot: aSlot name to: nil   ] 
	].
)
public synchronizeWithServer: aServer  = (
	| detectedChanges serverResponse clientUpdater |
	detectedChanges:: nil.

	root ifNil: [
		serverResponse:: aServer initialUpdate.
	] 
	ifNotNil: [
		detectedChanges:: cto detectChanges.
		detectedChanges changeLog versionId: currentVersion.
		serverResponse:: aServer synchronize: detectedChanges changeLog.
	].
	
	
	clientUpdater::  createClientUpdater.
	root:: clientUpdater updateFrom: detectedChanges to: serverResponse.
	resetTransientSlots.
	currentVersion:: serverResponse versionId.
)
) : (
)
class TransientObjectStore    = (
|
|	
) (
public containsNewObjectWithId: anId  = (
	subclassResponsibility
)
public containsObjectWithGuid: anIdentifier = (
	subclassResponsibility
)
public newObjectWithId: anId  = (
	subclassResponsibility
)
public objectWithGuid: anIdentifier = (
	subclassResponsibility
)
public registerNewObjects = (
	subclassResponsibility
)
public registerObject: anObject identifiedWith: id = (
	subclassResponsibility
				
)
reverseLookup: aMap = (
	| newMap |
	newMap:: Map new.
	
	aMap keysAndValuesDo: [ :k :v | newMap at: v put: k].
	^newMap
)
) : (
)
ArrayChange = (
	^ clientServerSync ArrayChange.
)
ArrayDefinition = (
	^ clientServerSync ArrayDefinition.
)
ClientToServerChangeLog = (
	^ clientServerSync ClientToServerChangeLog.
)
NewObjectReference = (
	^ clientServerSync NewObjectReference.
)
ObjectChangeRecord = (
	^ clientServerSync ObjectChangeRecord.
)
ObjectDefinition = (
	^ clientServerSync ObjectDefinition.
)
ObjectDefinitionWithIdentification = (
	^ clientServerSync ObjectDefinitionWithIdentification.
)
ObjectReference = (
	^ clientServerSync ObjectReference.
)
ObjectReferenceByMessageSend = (
	^ clientServerSync ObjectReferenceByMessageSend.
)
RegularObjectChange = (
	^ clientServerSync RegularObjectChange.
)
ServerToClientChangeLog = (
	^ clientServerSync ServerToClientChangeLog.
)
UnidentifiableObject = (
	^ clientServerSync UnidentifiableObject.
)
garbageCollect  = (
	Smalltalk garbageCollect. 
)
) : (
)
