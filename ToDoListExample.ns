Newspeak3
'OrthogonalSynchronization'
public class ToDoListExample usingPlatform: p  = (
|
	private platform  = p.
	Presenter =  platform hopscotch core Presenter. (* should be transient *) 
	Subject  =  platform hopscotch core Subject.   (* should be transient *)
	List = platform collections List.   (* should be transient *)
	HopscotchWindow = platform hopscotch core HopscotchWindow.  (* should be transient *)
	TextLineEditorFragment = platform hopscotch fragments TextLineEditorFragment. (* should be transien. Change to codeMirror: *)

	public model = ToDoListModel new.  
|
) (
class ToDoListModel = (
|
	pendingTasks_slot = List new.
	doneTasks_slot = List new.
	
|
) (
public class ToDoTask withDescription: aDescription  = (
|
	public description::= aDescription.
|
) (
) : (
)
public add: aTask = (
	pendingTasks_slot add: aTask.
)
public doneTasks = (
	^List withAll: doneTasks_slot.
)
public isDone: aTask = (
	^doneTasks_slot includes: aTask.
)
public isPending: aTask = (
	^pendingTasks_slot includes: aTask.
)
public markAsDone: aTask = (
	pendingTasks_slot remove: aTask.
	doneTasks_slot add: aTask.
)
public markAsPending: aTask = (
	doneTasks_slot remove: aTask.
	pendingTasks_slot add: aTask.
)
public pendingTasks = (
	^List withAll: pendingTasks_slot.
)
public remove: aTask = (
	pendingTasks_slot remove: aTask ifAbsent: [].
	doneTasks_slot remove: aTask ifAbsent: [].
	
)
) : (
)
public class ToDoListPresenter onSubject: s  = Presenter onSubject: s (
|
	addTaskHolder
	pendingTasksHolder
	doneTasksHolder
	
|
) (
addTaskLine = (
	^row: {
		label: 'New task'.
		(* filler. *)
		TextLineEditorFragment new
			text: '';
			acceptResponse: [:editor | respondToAdd: editor ];
			cancelResponse: [:editor | addTaskHolder content: nothing].
		
	}
)
definition  = (
	addTaskHolder:: holder: nothing.
	pendingTasksHolder:: list.
	doneTasksHolder:: list.
	
	refreshTasks.
	^ column: {
		link: 'New task' action: [ addTaskHolder content: addTaskLine ]  . 
		 
		pendingTasksHolder . 
		addTaskHolder .
		blank: 20 . 
		doneTasksHolder 
	}. 

)
definitionForDoneTasks = (
	^ subject doneSubjectElements collect: [:each | each createPresenter]
)
definitionForPendingTasks = (
	^ subject pendingSubjectElements collect: [:each | each createPresenter]
)
public refreshTasks = (
	pendingTasksHolder presenters: definitionForPendingTasks.
	doneTasksHolder presenters: definitionForDoneTasks.
	
)
respondToAdd: editor = (
	addTaskHolder content: nothing.
	subject newTaskWithDescription: editor text asString. 
	refreshTasks.
)
) : (
)
public class ToDoListSubject onModel: m  = Subject onModel: m  (
|
	
|
) (
public actionsFor: aTask do:  block = (
	
	(model isPending: aTask) ifTrue: [
		block value: 'Done!' value: [ model markAsDone: aTask   ].			
	].

	(model isDone: aTask) ifTrue: [
		block value: 'Back to Pending' value: [ model markAsPending: aTask   ].
	].
	
	block value: 'Remove' value: [  removeTask: aTask].

)
public canEdit: aTask = (
	^ model isPending: aTask.
)
public createPresenter = (
	^ ToDoListPresenter onSubject: self.
)
public doneSubjectElements = (
	
	^(model doneTasks collect: [:each |  ToDoSubject onModel: each parentSubject: self ]) reverse .
)
public newTaskWithDescription: taskDescription = (
	
	model add: (model ToDoTask withDescription: taskDescription).
	
)
public pendingSubjectElements = (

	^model pendingTasks collect: [:each |  ToDoSubject onModel: each parentSubject: self ].
)
public removeTask: task  = (
	model remove: task.
)
public title = (
	^'To Do List MVC Demo'
)
) : (
)
class ToDoPresenter onSubject: s = Presenter onSubject: s (
|	taskHolder availableActionsHolder |
) (
availableActions = (
	| result = List new. |

	subject canEdit ifTrue: [ result add:  (link:  'Edit' action: [  respondToEdit ] ) ].
	result add: (blank: 10).

	subject actionsDo: [ :actionName :action |
		result add:  (linkFor: actionName action: action).
		result add: (blank: 10).
	] .

	^result
)
definition = (

	taskHolder:: holder: nothing.  
	availableActionsHolder:: holder: nothing.
	
	refresh.

	^ row: {
				taskHolder .
				blank: 20. 
				availableActionsHolder
				
	}.

)
editDefinition = (
	
		 ^ row: { TextLineEditorFragment new
			text: subject taskDescription;
			acceptResponse: [:editor | 
				subject taskDescription: editor text asString.
				refresh. ];
			cancelResponse: [:editor |  refresh];
			yourself .
		}.  
	
)
labelDefinition = (
 	^label: subject taskDescription
	
)
linkFor: name action: anAction = (

	^link: name action: [ anAction value. 
						 sendUp refreshTasks.   ].

)
placeLabelDefinition = (
	taskHolder content: labelDefinition
)
refresh = (
	placeLabelDefinition.
	availableActionsHolder content: (row: availableActions).
)
respondToEdit = ( 
	taskHolder content: editDefinition. 
	availableActionsHolder content: nothing.
		
)
) : (
)
class ToDoSubject onModel:  m parentSubject: aSubject = Subject onModel: m (
|
	parentSubject = aSubject.
|
) (
public actionsDo: aBlock = (
	parentSubject actionsFor: self model do: aBlock.
)
public canEdit = (
	^parentSubject canEdit: self model
)
public createPresenter = (
	^ToDoPresenter onSubject: self.
)
public remove = (
	parentSubject removeTask: self model.
)
public task = (
	^ model
)
public taskDescription = (
	^ self model description
)
public taskDescription: aDescription = (
	^ self model description: aDescription
)
) : (
)
public start = (

	 HopscotchWindow openSubject:  (ToDoListSubject onModel: model) 
)
) : (
)
