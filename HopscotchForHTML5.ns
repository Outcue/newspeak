Newspeak3
'Hopscotch'
class HopscotchForHTML5 usingPlatform: p images: images = (
(* Hopscotch is Newspeak's UI framework. This version is implemented on top of HTML and CSS.

Copyright Google Inc. 2012 -2017
Copyright Ryan Macnak, Gilad Bracha 2018-2020.


This class defines a UI framework of the Newspeak platform on the web. Of course, one can use the DOM directly (as the code in this class does in its lower layers) or call any desired Javascript framework; but these are unpleasant, and we'd rather pave over the web's native horrors. 

This version is a work-in-progress toward a reactive version of Hopscotch; the long awaited Hopscotch II, whose design was interrupted in 2008.

The classes herein can be classified into: 

Windows/Shells
Fragments 
  - Presenters 
  - Composers
Navigation/History
Decorators

The entire process is driven by the window/shell classes. Normally, there is a HopscotchWindow encompassing the entire browser tab. However, one can also embed Hopscotch within HTML, and for this we have EmbeddedHopscotchWindow. Both inherit key behavior from HopscotchShell.

The key entry points are openSubject:, enterSubject, enterPresenter: and displayPresenter:; these are all methods of the window/shell classes. They call each other in the order listed above. Ultimately, displayPresenter: handles the insertion of a presenter's DOM tree into the actual DOM, so the browser will display it.

Fragments are logical view elements. In Web circles, the fragment tree might be thought of as a shadow-DOM.

Base fragments are defined by Hopscotch and map into DOM elements. The DOM element of a fragment is called its visual. A presenter is a special kind of fragment - essentially a higher-level user-defined fragment. A presenter computes a fragment tree to represent it using its #definition method. It is #displayPresenter: that invokes #definition to compute that fragment tree, and then extracts its visual using the #visual method of class Fragment. This yields a tree of DOM elements that it then inserts into the browser's current document.

Presenters have a slot called #substanceSlot. The substance is the fragment tree for rendering the presenter. It gets initialized lazily by a method called #ensureSubstance. This method runs #definition to compute the fragment tree, hooks up the back pointer from the fragment tree to its parent (the presenter) and calls #noticeSubstanceCreation, which is some sort of hook that lets code respond to this situation. No code uses it.

When a presenter is to be displayed by a HopscotchShell, it is asked for its visual, which is its native widget tree. If the visual has already been computed, it is available in the slot #visualX inherited from Fragment. Otherwise, #createVisual is called, which in turn calls #ensureSubstance.  This in turn will either invoke the #definition method to compute the fragment tree, or reuse the existing tree stored in #substanceSlot as noted above.

The effect will be to recursively produce a fragment tree and from it, a widget tree, caching these two so that they need not be recomputed at a later time (say, the next display cycle). In Hopscotch I, any changes had to be explicitly driven by the presenter by manipulating the substance directly (say, adding or removing method presenters in the class presenter).

To fix this to be reactive, we take the following approach:

UI actions that result in semantic changes must invoke  #updateUI: with a closure that takes the  desired semantic action.
After running the action, all subjects will be reset, meaning that they will flush their cached presenter. Redisplay will consequently recompute the state of the visual tree afresh based on the modified subjects (and their underlying models).

Most reactive frameworks endeavour to optimize this process to avoid excess recomputation of the visual tree. Typically this
involves a diff of the new and old fragment trees, to detect where changes have actually occurred and only rebuild the visuals of
the modified parts. In our case, such a diff is needed not only as an optimization, but to deal with stateful presenters or fragments.
For example, if a node in a tree-view (such as a method presenter) is open, we need to ensure that it remains open upon refresh. 
Likewise, if a node is being edited and the edit has not yet been saved, we must preserve the edited text.

In some systems, presenters are stateless, but this only moves the problem around. The above example remains necessary as a matter of good user experience; we can often move the state into the underlying application, but that state still needs to be managed. 

The diff process is driven by the #updateVisualsFrom: method of Fragment which accepts an old fragment to compare against. If fragments are not of the same kind, a new visual is computed and attached to the DOM at the right place.  To test whether fragments are of the same kind, they must implement #isMyKind:, which tests whether another fragment is of the same kind. The implementation is #isMyKind: is formulaic, calling #isKindOfX for whatever type X the presenter represents. 

If the incoming fragment parameter is of the same kind as the receiver,  #updateVisualsFrom: calls #updateFromSameKind: which Fragment subclasses must also implement. 

The method #updateFromSameKind:  is responsible for computing  the visual for the fragment, utilizing any relevant information from the old fragment. Typically this means preserving any state that should be retained across refreshes. Where possible, part or all of the original visual is reused. Using the visual returned by #updateFromSameKind:, #updateVisualsFrom: updates the cached visual of the fragment. 

In many cases, users of the framework can rely on the #updateFromSameKind: implementation of Presenter. However, if the user code has interesting state that requires deeper semantic understanding to preserve, this may not be sufficient. In that case, there are two choices:

a. Override #updateFromSameKind: in presenter class(es). 
b. Capture the state in a suitable subject class.

(b) is usually preferred, but there are cases where the state is entirely related to presentation and therefore (a) is required. 

Ensuring that all built-in fragments implement this protocol correctly, and applying it to the existing presenter classes of the web IDE is an ongoing process. So far, we have not seen a substantial performance problem (at least on desktops).  The main problems are preserving the state of presenters (the IDE presenters are mostly stateful for the reasons indicated above).

Moving forwards and backwards in the browser should display correctly updated views while preserving presenter state. Presenters
and subjects must be aware of the requirements imposed to support this requirement. See #NavigationHistory and #LocalNavigationHistory for a description.

See comments in Fragment, Presenter and Subject for more details.

Further documentation of subjects and decorators will be added in the future.
*)
|
	private Color = p graphics Color.
	private Context = p graphics Context.
	private Timer = p actors Timer.
	private List = p collections List.
	private Map = p collections Map.
	private Set = p collections Set.
	private TextBlock = p text TextBlock.
	private TextProperties = p text TextProperties.
	private TextString = p text TextString.
	private window = p js global.
	private document = window at: 'document'.
	JSObject = p js global at: 'Object'.
	private body = document at: 'body'.
	private history = window at: 'history'.
	sharedNavigationHistory
	embeddedWindowMap = Map new.
	sharedBackButtonListener
	currentHopscotchWindow

	private accept16px = images accept16px.
	private cancel16px = images cancel16px.
	private disclosureClosedImage = images disclosureClosedImage.
	private disclosureTransitionImage = images disclosureTransitionImage.
	private disclosureOpenImage = images disclosureOpenImage.
	public dropDownImage = images dropDownImage.
	public dropDownOutImage = images dropDownOutImage.
	public dropDownOverImage = images dropDownOverImage.

	private deferredContentQueue = List new.
	public core = self. (* Polymorphic with HopscotchForBrazil *)
	public fragments = self. (* Polymorphic with HopscotchForBrazil *)
	|) (
class BlankFragment = LeafFragment (
) (
createVisual = (
	^document createElement: 'div'
)
public isKindOfBlankFragment ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfBlankFragment
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^oldFragment visual
)
) : (
)
class ButtonFragment label: l action: a = LeafFragment (|
	public label = l.
	action = a.
	public enabled ::= true.
|) (
createVisual = (
	^(document createElement: 'button')
		appendChild: (document createTextNode: label);
		at: 'onclick' put: [:event | action value. false];
		at: 'disabled' put: enabled not;
		yourself
)
public isKindOfButtonFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfButtonFragment
)
updateVisualsFromSameKind: oldFragment <ButtonFragment>  ^ <Alien[ButtonElement]> = (
| oldVisual = oldFragment visual.|
   oldVisual at: 'onclick' put: [:event | action value. false];
		 at: 'disabled' put: enabled not.
   oldFragment label ~= label ifTrue: [
	oldVisual replaceChild: (document createTextNode: label) oldChild: (oldVisual at:  'firstChild')
	].
   ^oldVisual
)
) : (
)
class CallBackWrapper wrapping: h = (
|
	public callback <[]> ::= h.
|
) (
public wrappedCallback = (
 ^[:a1 :a2 | callback value: a1 value: a2]
)
) : (
)
class CanvasFragment withExtent: e = LeafFragment (
	|
	private alien = document createElement: 'canvas'.
	|
	alien at: 'width' put: e x.
	alien at: 'height' put: e y.
	(alien at: 'style') at: 'position' put: 'relative'.
) (
public context = (
	^Context on: (alien getContext: '2d')
)
createVisual = (
	^alien
)
public isKindOfCanvasFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfCanvasFragment
)
public keyDownAction: onKeyPressed <[:String]> = (
	(* The canvas element itself doesn't seem to get key events. *)
	body addEventListener: 'keydown' action: 
		[:event | onKeyPressed value: (String fromCharCode: (event at: 'keyCode')). nil].
)
public mouseDownAction: onMouseDown <[:Point]> = (
	alien addEventListener: 'mousedown' action: 
		[:event | onMouseDown value: (event at: 'offsetX') @ (event at: 'offsetY'). nil].
)
public mouseMovedAction: onMouseMoved <[:Point]> = (
	alien addEventListener: 'mousemove' action:
		[:event | onMouseMoved value: (event at: 'offsetX') @ (event at: 'offsetY'). nil].
)
updateVisualsFromSameKind: oldFragment <CanvasFragment>  ^ <Alien[Canvas]>  = (
  ^oldFragment visual
)
) : (
)
public class CodeMirrorFragment onText: t <String>  = LeafFragment (
(* An experiment to see how to integrate CodeMirror as editor. *)
|
      public editor <Alien[CodeMIrror]>
	textSlot <TextFragment | String> ::= t.
	public counterfactualBar <Alien[Span]>
	public isInEditState ::= false.
	public changeResponse <[TextEditorFragment]>
	public acceptResponse <[TextEditorFragment]>
	public cancelResponse <[TextEditorFragment]>
	styles ::= List new.
	public changeHandler <CallBackWrapper>
	lastChangeWasSynthetic <Boolean> ::= false.
	public readOnly <Boolean> ::= false.
|
) (
applyStyle: style <{Integer. Integer. Alien[JSObject]}> = (
	| s <Alien[CodeMirrorPosition]> e <Alien[CodeMirrorPosition]> |
	(* Newspeak intervals are 1-origin and [start, stop]. JS intervals are 0-origin and [start, stop). *)
	s:: editor posFromIndex: (style at: 1) - 1.
	e:: editor posFromIndex: (style at: 2).
	editor markText: s to: e style: (style at: 3).
)
applyStyles = (
    nil = editor ifFalse: [
	styles do: [: s <{Integer. Integer. Alien[JSObject]}> |
	applyStyle: s
	].
     styles:: List new.
     editor refresh.
   ]
)
controlBarColor = (
	^Color r: 0.95 g: 0.792 b: 0.475
)
createVisual = (
	| frame  <Alien[Div]> accept  <Alien[Img]> cancel <Alien[Img]> textArea <Alien[Span]> options <Alien[JSObject]> |
	frame:: document createElement: 'div'.
	(frame at: 'style')
		at: 'display' put: 'flex';
		at: 'opacity' put: 1.
	counterfactualBar:: document createElement: 'span'.
	(counterfactualBar at: 'style')
		at: 'backgroundColor' put: controlBarColor asCSSString;
		at: 'flex' put: 'none'.
	accept:: document createElement: 'img'.
	accept at: 'src' put: (accept16px yourself at: 'src').
	(accept at: 'style') at: 'margin' put: '3px'.
	accept at: 'onclick' put:
		[:event | respondToAccept: event. nil].
	cancel:: document createElement: 'img'.
	cancel at: 'src' put: (cancel16px yourself at: 'src').
	(cancel at: 'style') at: 'margin' put: '3px'.
	cancel at: 'onclick' put:
		[:event | respondToCancel. nil].
	counterfactualBar appendChild: accept.
	counterfactualBar appendChild: cancel.
	textArea:: document createElement: 'textarea'.
	textArea
		at: 'value' put:  textSlot;
		at: 'resize' put: true.
	frame appendChild: textArea.
	options:: JSObject new.
	options at: 'lineWrapping' put: true.
	options at: 'readOnly' put: readOnly.
	editor:: CodeMirror fromTextArea: textArea with: options.
      registerChangeHandler.
	((textArea at: 'nextSibling') at: 'style') 
		at: 'height' put: 'unset';
		at: 'width' put: '100%';
		at: 'fontFamily' put: 'TimesNewRoman';
		at: 'borderStyle' put: 'solid';
		at: 'borderWidth' put: '1px';
		at: 'borderColor' put: 'gray'.
	^frame
)
public defaultAcceptResponse = (
      textSlot:: editor getValue.
	leaveEditState
)
public defaultCancelResponse = (
	editor setValue: textSlot.
	leaveEditState
)
public defaultChangeResponse = (
	enterEditState
)
public enterEditState = (
      lastChangeWasSynthetic ifTrue: [lastChangeWasSynthetic:: false. ^self].
	isInEditState ifFalse:
		[visual appendChild: counterfactualBar.
		isInEditState:: true].
	visual scrollIntoView: true (* alignWithTop *).
)
public isKindOfCodeMirrorFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfCodeMirrorFragment
)
public leaveEditState = (
	isInEditState ifTrue:
		[visual removeChild: counterfactualBar.
		isInEditState:: false.
		(*removeMessages*)]
)
public noticeExposure = (
  refresh
)
public refresh = (
  applyStyles
)
registerChangeHandler = (
      changeHandler:: CallBackWrapper wrapping: [:codeMirror :change | respondToChange: codeMirror. nil].
      editor on: 'change' respondToChange: changeHandler wrappedCallback.
)
respondToAccept: event <Alien[Event]> = (
	nil = acceptResponse
		ifTrue: [defaultAcceptResponse]
		ifFalse: [acceptResponse cull: self cull: event]
)
respondToCancel = (
	(*confirm: 'Confirm Cancel' ifConfirmed:
		[*)nil = cancelResponse
			ifTrue: [defaultCancelResponse]
			ifFalse: [cancelResponse cull: self](*]*)
)
respondToChange: event <Alien[Event]> = (
	nil = changeResponse
		ifTrue: [defaultChangeResponse]
		ifFalse: [changeResponse cull: self cull: event]
)
public showMessage: message <String> = (
	message out.
)
public style: style <Alien[JSObject]> from: start <Integer> to: end <Integer>  = (
	styles add: {start. end. style}.
	applyStyles
)
public text: t = (
      textSlot:: t.
	hasVisual ifTrue: [editor setValue: t].
)
public textBeingAccepted ^ <String> = (
  ^editor getValue
)
updateVisualsFromSameKind: oldFragment <CodeMirrorFragment>  ^ <Alien[CodeMIrror]> = (
	isInEditState:: oldFragment isInEditState.
      changeHandler:: oldFragment changeHandler.
	editor:: oldFragment editor.
	readOnly:: oldFragment readOnly.
      isInEditState ifTrue: [
		textSlot:: oldFragment editor getValue
		] ifFalse: [	
		lastChangeWasSynthetic:: true.
		editor setValue: textSlot.
		oldFragment leaveEditState.
		].
	counterfactualBar:: oldFragment counterfactualBar.
	(counterfactualBar at: 'firstChild') at: 'onclick' put:
		[:event | respondToAccept: event. nil].
	(counterfactualBar at: 'lastChild') at: 'onclick' put:
		[:event | respondToCancel. nil].
      changeHandler callback:  [:codeMirror :change | respondToChange: codeMirror. nil].
	^oldFragment visual
)
) : (
)
class ColorDecorator color: c <Color> = Decorator (
| color <Color> = c. |) (
public decorate: aVisual = (
	color applyToStyle: (aVisual at: 'style').
	^aVisual
)
) : (
)
class ColumnComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (
	crossAxisStretch
) (
flexDirection ^ <String> = (
	^'column'
)
public isKindOfColumnComposer ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfColumnComposer
)
) : (
)
class Composer = Fragment () (
) : (
)
public class Decorator = (
(* A Decorator is attached to a fragment and is called by the fragment to change the various attributes of the Brazil visual created by the fragment itself. *)
) (
public decorate: aVisual = (
	(* Change properties of aVisual or wrap it into a new visual that applies whatever decorating we represent to aVisual. Answer aVisual or the new visual. *)
	subclassResponsibility
)
) : (
)
class DeferredContentComposer initialContent: ic contentSource: cs = Composer (|
	initialContent <Fragment> = ic.
	contentSource <[Fragment]> = cs.
	contentFragment <Fragment>
|) (
public childrenDo: aBlock = (
	nil = contentFragment 
	  ifFalse: [aBlock value: contentFragment]
	  ifTrue: [aBlock value: initialContent]
)
createVisual = (
	| div initialVisual |
	div:: document createElement: 'div'.
	(div at: 'style') at: 'align-self' put: 'center'.
	initialVisual:: initialContent visual.
	div appendChild: initialVisual.
	deferAction: [
		| deferredFragment = contentSource value. |
		deferredFragment parent: self.
		contentFragment:: deferredFragment.
		(* replace: new with: old due to stupid DOM argument ordering *)
		div replaceChild: deferredFragment visual with: initialVisual].
	^div
)
public isKindOfDeferredContentComposer ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDeferredContentComposer
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  | oldVisual = oldFragment visual. |
	deferAction: [
		| deferredFragment = contentSource value. |
		deferredFragment parent: self.
		contentFragment:: deferredFragment.
		(* replace: new with: old due to stupid DOM argument ordering *)
		oldVisual replaceChild: deferredFragment visual replacing: (oldVisual at: 'firstChild')]. 
	^oldVisual  
)
) : (
)
class DropDownMenuFragment menu: ms images: ims <Array[Image]> alignment: side <Symbol>  = 
  ImageButtonFragment images: ims action: [] (
(*
Create a drop down menu based on dynamic content. This means that the menu contents may vary every time the menu button
is clicked.  The contents are computed by a closure provided by the ms argument to the factory, and stored in the
menuSupplier slot.  The images to use for the menu button are provided by the ims argument.  Menus may be aligned to the right
or the left; ideally, the system would figure the best alignment dynamically, but for now it must be specified via the side argument. Usually the presenter has a good idea what side the menu should be aligned to, so this is not a high priority item to address.

Class methods that provide convenient defaults for the button images and the alignment are provided as well.
*)
	|
	menuSupplier <[Tuple[Symbol | Tuple[String, []]]]> = ms. (* Skip formal menu structure for now*)
	menuActive <Boolean> ::= false.
	alignment <String>  = side asString.
	|
) (
createVisual ^ <Alien[Element]> = (
	| column = super createVisual. |
	column addEventListener: 'click' action: [:event | toggleContent. nil].
	(column at: 'style')
		at: 'cursor' put: 'pointer'.
	^column
)
public isKindOfDropDownMenuFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDropDownMenuFragment
)
removeContent ^ <Alien[Element]> = (
	^visual removeChild: (visual at: 'lastChild')
)
toggleContent = (
	menuActive ifTrue: [removeContent] ifFalse: [updateContent].
	menuActive:: menuActive not.
)
updateContent ^ <Alien[Element]> = (
	| menuContent <Alien[Div]> |
	menuContent:: computeContentForMenu: menuSupplier.
	(menuContent at: 'style') 
	   at: alignment put: 0;
	   at: 'display' put: 'block'.
	visual appendChild: menuContent.
	^menuContent
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^visual (* optimize later? Does it even matter? *)
)
) : (
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> ^ <Instance> = (
   ^menu: ms images: {dropDownImage. dropDownOverImage. dropDownOutImage} alignment: #right
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> alignment: side <Symbol> ^ <Instance> = (
   ^menu: ms images: {dropDownImage. dropDownOverImage. dropDownOutImage} alignment: side
)
public menu: ms  <[Tuple[Symbol | Tuple[String, []]]]> images: ims <Array[Image]> ^ <Instance> = (
   ^menu: ms images: ims alignment: #right
)
)
public class EmbeddedHopscotchWindow into: container openSubject: s = HopscotchShell (
	|
	localNavigator = LocalNavigationHistory new.
	|
	container appendChild: contentHolder.
	enterSubject: s.
) (
public displayPresenter: p <Presenter> = (
	super displayPresenter: p.
	(* Not a full-page app: don't update document title. *)
)
public enterPresenter: p <Presenter> = (
	currentHopscotchWindow:: self.
	embeddedWindowMap at: p ifAbsentPut: [self].
	localNavigator visit: p.
	super enterPresenter: p
)
public enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (
	embeddedWindowMap at: snippet presenter ifAbsentPut: [self].
	enterSubject: s.
)
public goBack = (
	localNavigator goBack.
	displayPresenter: localNavigator current.
)
listenForBackButton = (
	nil = sharedBackButtonListener ifFalse: [^self. (* Already listening. *)].
	sharedBackButtonListener::
		[:event <Alien[Event]> |
		| p <Presenter> = navigator presenterFor: (event at: 'state').
		priorWindow = embeddedWindowMap at: p. |
		currentHopscotchWindow goBack. (* might be better to enterPresenter:? *)
		currentHopscotchWindow:: priorWindow].
	window at: 'onpopstate' put: sharedBackButtonListener.
)
navigationHistory = (
	^sharedNavigator
)
) : (
public openSubject: s = (
	^into: body openSubject: s
)
)
class Fragment = (
(*
The root of the hierarchy for logical UI tree nodes.

Subclasses that embed subtrees must ensure that they update the parent link of the subtree when creating a visual
or manipulating it (i.e., via updateVisualsFrom:).

Fragments must implement #isMyKind:, which tests whether another fragment is of the same kind. The implementation is #isMyKind: is formulaic, calling #isKindOfX for whatever type X the presenter represents. 

They must also implement #createVisual, which is usedto create the concrete widget tree representing this fragment.

Another subclass responsibility is #updateVisualsFromSameKind:, which updates the fragment's visuals based on a
(presumably older) fragment of the same kind.

*)
      |
	visualX
	public parent
	public size ::= nil.
	public expansibility ::= 0.
	public compressibility ::= 0.
	decorators
	|) (
public addDecorator: newDecorator <Decorator> = (
	(* The argument is added last to the collection of our decorators, meaning it will be applied after all the other decorators we might have. *)
	nil = decorators ifTrue: [decorators:: List new].
	decorators addLast: newDecorator.
)
createVisual = (
	subclassResponsibility
)
public decorate: aVisual = (
	(* The argument is a visual freshly created by the #createVisual or #createViewportWithVisual method. If we have any decorators attached, apply them now to arrive at the final decorated visual. *)
	| decorated |
	decorated:: aVisual.
	nil = decorators ifFalse:
		[decorators do: [:each | decorated:: each decorate: decorated]].
	^decorated
)
public elasticity: x = (
	expansibility: x.
	compressibility: x.
)
public hasVisual = (
	^visualX isNil not
)
isMyKind: f <Fragment> ^ <Boolean> = (
(* Every fragment type X needs to have an implementation of this that amounts to:
    isMyKind: f <Fragment> ^ <Boolean> = (
      ^f isKindOfX
   )

along with an implementation of isKindOfX:  public isKindOfX ^ <Boolean> = (true)
*)
  subclassResponsibility
)
public noticeExposure = (
	(* Propagated down the fragment hierarchy just after the hierarchy has been made visible. A fragment may receive this message multiple times over its life. Used by certain leaf fragments,such as CodeMirrorFragment, who may need to explicitly refresh themselves upon exposure as they have no direct connection to changed subjects. *)

	childrenDo: [:each | each noticeExposure]
)
public refresh = (
	(* Fragments that dynamically retrieve their information should reimplement this to update their visuals accordingly. *)

	childrenDo: [:each | each refresh]
)
public replaceVisual: oldVisual <Alien[Element]> with: newVisual <Alien[Element]>  = (
  | oldParent <Alien[Node]> = oldVisual at: 'parentNode'. | 
  oldParent isNil ifFalse: [oldParent replaceChild: newVisual replacing: oldVisual].
  ^newVisual
)
public shell = (
	^parent isNil
		ifTrue: [Error signal: 'hierarchy not installed in a shell :',  printString]
		ifFalse: [parent shell]
)
updateGUI: action <[Object]> = (
(* provide access to surrounding window's #updateGUI: mechanism *)
   updateAllWindows: action
)
public updateVisualsFrom: oldFragment <Fragment> = (
  (isMyKind: oldFragment) ifTrue: [
    visualX:: oldFragment hasVisual ifTrue: [updateVisualsFromSameKind: oldFragment]
  ] ifFalse: [
    replaceVisual: oldFragment visual with: visual
  ]
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
(* 
This method must never be called unless oldFragment hasVisual = true 
Returns the updated  visual of the fragment,  cognizant of data in
oldFragment.  Any state that the fragment maintains should be preserved in the new visual.
The visual returned will often be oldFragment's visual, patched to be up to date as needed.
In other cases, the new visual is computed, but updated to reflect state from olfFragment.
*)
  subclassResponsibility
)
public value = (
	^self
)
public visual = (
	visualX isNil ifTrue: [visualX:: decorate: createVisual].
	^visualX
)
public width: w elasticity: e = (
	size: w. 
	expansibility: e. (* These 2 lines just inline elasticity:. Is that necessary? *)
	compressibility: e.
)
) : (
)
public class Gradient from: a to: b = (|
	topColor = a.
	bottomColor = b.
|) (
public applyToStyle: style = (
	| value |
	value:: '(top,', topColor asCSSString, ',', bottomColor asCSSString, ')'.
	style setProperty: 'background-image' to: '-webkit-linear-gradient', value.
	style setProperty: 'background-image' to: '-moz-linear-gradient', value.
)
) : (
)
class HolderComposer withContent: definition <Fragment | [Fragment]> = Composer (|
	contentSource <Fragment | [Fragment]> ::= definition.
	actualContent <Fragment>
|) (
public childrenDo: aBlock <[:Fragment]> = (
	nil = actualContent ifFalse: [aBlock value: actualContent].
)
public content ^<Fragment> = (
	nil = actualContent ifTrue:
		[actualContent:: contentSource value.
		actualContent parent: self].
	^actualContent
)
public content: fragment = (
 | oldContent newContent |
	fragment parent: self.
	hasVisual ifTrue:
		[
		oldContent:: actualContent.
		newContent:: actualContent:: fragment.
		(* replace: new with: old due to stupid DOM argument ordering *)
		assert: [oldContent visual contains: (visual at: 'firstChild')] message: 'holder invariant broken 1'.
		visual replaceChild: newContent visual with: oldContent visual.
		assert: [actualContent visual contains: (visual at: 'firstChild')] message: 'holder invariant broken2'.	
		]
	ifFalse: [contentSource:: actualContent:: fragment]
)
createVisual = (
	| div |
	div:: document createElement: 'div'.
	div appendChild: content visual.
	^div
)
public isKindOfHolderComposer ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfHolderComposer
)
public noticeExposure = (
  refresh
)
public refresh = (
	(contentSource isKindOfClosure and: [hasVisual])
		ifTrue:
			[ | oldContent newContent |
			oldContent:: actualContent.
			actualContent:: nil.
			newContent:: content.
			(* replace: new with: old due to stupid DOM argument ordering *)
			visual replaceChild: newContent visual with: oldContent visual.
			]
		ifFalse:
			[actualContent refresh].
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  content updateVisualsFrom: oldFragment content.
  assert: [actualContent visual contains: (oldFragment visual at: 'firstChild')]message: 'holder invariant broken 3'.
  ^oldFragment visual
)
) : (
)
class HopscotchShell = (
	|
	navigator = navigationHistory.
	currentPresenterX
	contentHolder = document createElement: 'div'.
	|
	listenForBackButton.
) (
public childrenDo: aBlock = (
	aBlock value: currentPresenter
)
public currentPresenter = (
	^currentPresenterX
)
public displayPresenter: p = (
	(* TODO: noticeX events *)
	currentPresenterX:: p.
	p parent: self.
	contentHolder hasChildNodes
		ifTrue: [contentHolder replaceChild: p visual from: (contentHolder at: 'firstChild')]
		ifFalse: [contentHolder appendChild: p visual].
	p noticeExposure.
)
public enterPresenter: presenter = (
  | oldPresenter newPresenter |
	currentHopscotchWindow:: self.
	newPresenter:: presenter refreshmentPresenter.
	newPresenter isTransient ifFalse:
		[nil = currentPresenterX
			ifTrue: [navigator recordFirst: newPresenter]
			ifFalse: [history pushState: (navigator idFor: newPresenter) title: newPresenter title]].
	displayPresenter: (navigator equalVisitOr: newPresenter).
)
public enterSubject: s <Subject> = (
	self enterPresenter: s presenter
)
listenForBackButton = (
	window at: 'onpopstate' put: [:event | userBack: event. nil]
)
navigationHistory = (
	^NavigationHistory new
)
public refresh = (
	(* Since refreshing forces a new copy of the current presenter into the browser, we need to massage it into the history as well. *)

	| newSubject |
	newSubject:: currentPresenter subject refreshmentSubject.
	displayPresenter: newSubject presenter.
	(* navigator replaceCurrentWith: newSubject presenter. *)
)
public registerNewPresenter: newPresenter <Presenter> = (
  navigator registerNewPresenter: newPresenter
)
public replaceVisual: oldVisual <Alien[Element]> with: newVisual <Alien[Element]> = (
    (* Do nothing. This is just a stub so that all fragments,
       including the top level presenter can invoke this method uniformly 
   *)
)
public resetSubjects = (
  currentPresenter resetSubject.
  navigator resetSubjects
)
public shell = (
	^self
)
public updateGUI: action <[Object]> = (
(* This function is called whenever an event occurs; ergo, any event-handling call-back should call this function. The argument , action,  implements the desired response to the event.
   Then action is invoked. Then, we reset all subjects, which clears out all the cached presenters.

   A new fragment tree is computed. We then compare it against the old fragment tree,
   and where changes have occurred, a new visual is computed and inserted into the DOM as needed.
*)
| 
  oldPresenter <Presenter> = currentPresenter.
  newPresenter <Presenter>
|
  action value. (* Does this change currentPresenter? *)
  allWindowsResetSubjects.
  newPresenter:: currentPresenter refreshmentPresenter.
  assert: [(oldPresenter == newPresenter) not] message: 'Presenter not replaced!'.
  displayPresenter: newPresenter.
)
userBack: event = (
| 
  oldPresenter <Presenter> = navigator presenterFor: (event at: 'state').
  newPresenter <Presenter>
|
   assert: [oldPresenter isNil not] message: 'no presenter at id for state!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'.
   oldPresenter resetSubject.
   newPresenter:: oldPresenter refreshmentPresenter.
   displayPresenter: newPresenter.
)
) : (
)
public class HopscotchWindow into: container openSubject: s = HopscotchShell (
	container appendChild: contentHolder.
	enterSubject: s.
) (
public displayPresenter: p = (
	super displayPresenter: p.
	document at: 'title' put: p title.
)
) : (
public openSubject: s = (
	^into: body openSubject: s
)
)
class HyperlinkFragment label: l action: a = LeafFragment (|
	public label = l.
	action = a.
	public color ::= Color r: 0 g: 0 b: 1.
|) (
createVisual = (
	| anchor |
	anchor:: document createElement: 'a'.
	anchor at: 'href' put: '#'.
	anchor appendChild: (document createTextNode: label).
	anchor at: 'onclick' put: [:event | action value. false].
	(anchor at: 'style')
		at: 'textDecoration' put: 'none'; (* No underline *)
		at: 'overflow' put: 'hidden';
		setProperty: 'white-space' to: 'nowrap'.
	color isNil ifFalse:
		[(anchor at: 'style') setProperty: 'color' to: color asCSSString].
	^anchor
)
public isKindOfHyperlinkFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfHyperlinkFragment
)
public smallFont = (
	(visual at: 'style') at: 'font-size' put: 'smaller'
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  | oldVisual = oldFragment visual.|
  oldVisual at: 'onclick' put: [:event | action value. false].
  oldFragment label ~= label ifTrue: [
	oldVisual replaceChild: (document createTextNode: label) replacing: (oldVisual at: 'firstChild').
	].
  ^oldVisual
)
) : (
)
class HyperlinkImageFragment image: i action: a = LeafFragment (|
	image = i.
	action =  a.
|) (
createVisual = (
	| img |
	img:: image cloneNode: false (* Not deep *).
	img at: 'onclick' put: [:event | action value. false].
	^img
)
public isKindOfHyperlinkImageFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfHyperlinkImageFragment
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^visual (* optimize later? Does it even matter? *)
)
) : (
)
class ImageButtonFragment images: imageArray <Array[Image]> action: aBlock <[]> = LeafFragment (
(* A button displayed as an image; or an image that acts as a button. *)
|
	public action <[]> = aBlock.
	public stateImages <Array[Image]> = imageArray, (Array new: 3).
	(* Appending three nils so that we can always send #at: with an index between 1 and 4 and expect it not to fail. *)
|) (
createVisual ^ <Visual> = (
	| div img |
	div:: document createElement: 'div'.
	(div at: 'style')
		at: 'display' put: 'flex';
		at: 'flex-direction' put: 'flex-column';
		at: 'align-items' put: 'center'.
	img:: (stateImages at: 1) cloneNode: false (* Not deep *).
	img at: 'onclick' put: [:event | action value. false].
	div appendChild: img.
	^div
)
public isKindOfImageButtonFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfImageButtonFragment
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
| oldVisual = oldFragment visual. img = oldVisual at: 'firstChild'.|
  #BOGUS.  (* what if the actual images are different? *)
   img at: 'onclick' put: [:event | action value. false].
   ^oldVisual
)
) : (
)
class LeafFragment = Fragment () (
public childrenDo: aBlock = (
	(* No children. *)
)
) : (
)
class LocalNavigationHistory = (
(* LocalNavigationHistory is a richly structured collection that maintains a web browser-like history of ''visits''. Visits are arbitrary objects. NavigationHistory makes no assumptions about visits other than that they can be compared using #=.

The important attributes of a history are: the ''current'' visit, the ''past'', the ''future'' and ''allVisits''. A history starts off empty. To visit an object, send the #visit: message to the history with the object as the argument. This makes the object the ''current'' object of the history.

The ''past'' is a queue of visits that used to be the current (most recently current object last). Sending the #goBack message makes the most recently current object from the past the current again, while the current object becomes the first member of the ''future'' queue. Sending the #goForward message reverses the process. Visiting an object other than the first element of the ''future'' queue erases the future queue.

All visits visited by a history are remembered in the ''allVisits'' set. This set is never emptied, other than on an explicit request.

A history can optionally be configured with a transientTestBlock. The test block is applied to visits to determine whether they are transient or not. Transient visits are not recorded in the ''past'' and ''future'' queues and in the ''allVisits'' set. By default all visits are considered to be non-transient.
*)
	|
	currentVisitSlot
	public allVisits <List>
	public past <List>
	public future <List>
	public transientTestBlock <[:Object | Boolean]> ::= [:element | false].
	|
	erase.
) (
public current ^ <Object> = (
	^currentVisitSlot
)
public do: aBlock = (
	(* Do the current visit separately if transient because it's not among allVisits. *)
	(isTransient: currentVisitSlot) ifTrue:
		[aBlock value: currentVisitSlot].
	allVisits do: aBlock
)
public equalVisitOr: anObject ^ <Object> = (
	(* Return a visit from the history equal to the argument, or the argument itself if there is no equal visit in the history. *)
	^allVisits detect: [:some | some = anObject] ifNone: [anObject]
)
public erase = (
	currentVisitSlot:: nil.
	allVisits:: List new.
	erasePast.
	eraseFuture.
)
public eraseEntry: anObject = (
	allVisits remove: anObject.
	past remove: anObject ifAbsent: [].
	future remove: anObject ifAbsent: []. (* can it ever be in the future list? *)
)
eraseFuture = (
	future:: List new.
)
erasePast = (
	past:: List new.
)
public goBack = (
	isPastEmpty ifFalse:
		[(isTransient: currentVisitSlot) ifFalse:
			[future addFirst: currentVisitSlot].
		currentVisitSlot:: past removeLast]
)
public goForward = (
	isFutureEmpty ifFalse:
		[(isTransient: currentVisitSlot) ifFalse:
			[past addLast: currentVisitSlot].
		currentVisitSlot:: future removeFirst]
)
public goToFutureItem: anObject = (
	[currentVisitSlot = anObject or: [isFutureEmpty]]
		whileFalse: [goForward]
)
public goToPastItem: anObject = (
	[currentVisitSlot = anObject or: [isPastEmpty]]
		whileFalse: [goBack]
)
includesVisit: anObject ^ <Boolean> = (
	^allVisits includes: anObject
)
isEmpty ^ <Boolean> = (
	^allVisits isEmpty
)
public isFutureEmpty ^ <Boolean> = (
	^future isEmpty
)
public isPastEmpty ^ <Boolean> = (
	^past isEmpty
)
isTransient: anObject ^ <Boolean> = (
	^transientTestBlock value: anObject
)
next ^ <Object> = (
	(* Answer the closest visit from the future. Fail if the future is empty. *)
	^future first
)
previous ^ <Object> = (
	(* Answer the most recent visit from the past. Fail if the past is empty. *)
	^past last
)
replace: anObject with: replacement = (
	(* Replace all references to anObject that we have with references to 'replacement'. *)
	allVisits remove: anObject ifAbsent: [].
	(isTransient: replacement) ifFalse: [allVisits add: replacement].
	currentVisitSlot = anObject ifTrue: [currentVisitSlot:: replacement].
	past keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [past at: index put: replacement]].
	future keysAndValuesDo:
		[:index :each | each = anObject ifTrue: [future at: index put: replacement]]
)
public replaceCurrentWith: anObject = (
	self replace: currentVisitSlot with: anObject
)
public resetSubjects = (
  do: [:v | v resetSubject]
)
public visit: anObject = (
	(* Make the argument the current object of the history. The prior current object becomes the last object of the 'past' queue. The 'future' queue is erased, unless the visit is equal to the first element of the future. *)
	currentVisitSlot = anObject ifTrue: [^self].
	((nil = currentVisitSlot) not and: [(isTransient: currentVisitSlot) not]) ifTrue:
		[past addLast: currentVisitSlot].
	currentVisitSlot:: anObject.
	(isTransient: anObject) ifFalse:
		[allVisits
			remove: anObject ifAbsent: [];
			add: anObject].
	future isEmpty not ifTrue:
		[future first = currentVisitSlot
			ifTrue: [future removeFirst]
			ifFalse: [eraseFuture]].
)
) : (
)
class NavigationHistory = (
(*
The Web version of Hopscotch leaves navigation to the surrounding web browser. 
Nevertheless, we need to interact with this process so that the presenters displayed
are up to date. Hence all navigation involves a navigation history of some sort.

This class serves the needs of an application where Hopscotch occupies the entire page.

Each page has an id,  stored in a Javascript #state property with a numeric value. This class manages those ids. 
When a new presenter is displayed, it is given an id. Ids start at 1. Allocating an id involves 
incrementing a counter (nextId) and placing the new id in a map, #ids, keyed by the new presenter. 
We assume that doubles are large enough to track all the presenters in an application - we will run out of memory
, both digital and human, long before we hit that limit. Actual allocation happens in #idFor: .

When an existing page is displayed, the callback for web browser navigation uses
the value of its state property as the id to lookup the presenter.
Lookup is done via the method #presenterFor:, which either finds an existing entry in #ids, 
or returns nil.  

Presenter equality is based on subject equality. Developers determine subject equality, which defaults to model equality.
Hence looking up an id for a presenter on an existing (or more generally, equivalent) subject
always works, even when fresh presenters are computed. This should ensure that #presenterFor: 
never returns nil as long as it is passed the id of an existing page.

When navigating to a new page (e.g., via a link or button) we must always check whether an equivalent presenter
exists in the history, so that we display the correct presenter state. This check is done via
#equalVisitOr:.  If an old presenter is returned, the caller must use it to update the new one
to the proper state. 

The above paragraph also holds when updating an existing presenter due to subject/model changes.

The navigator must be told that the newly computed presenter is the latest
version in its equivalence class, so that:

a. The keys of #ids are updated, so that lookups for #presenterFor: used during history navigation
    return correct results.
b.  To prevent memory leaks which would occur if we kept old presenters live via the keys of #ids.

This should be done by calling #registerNewPresenter:
*)
| nextId ::= 1. ids <Map[Presenter, Integer]> = Map new. |
) (
public allVisits ^ <List[Presenter]> = (
  ^ids keys
)
public equalVisitOr: anObject ^ <Object> = (
	(* Return a visit from the history equal to the argument, or the argument itself if there is no equal visit in the history. *)
	^allVisits detect: [:some | some = anObject] ifNone: [anObject]
)
public idFor: presenter <Presenter> ^ <Integer> = (
	^ids at: presenter ifAbsentPut: [nextId:: nextId + 1]
)
public presenterFor: id <Integer> ^ <Presenter | Nil> = (
	ids keysAndValuesDo:
		[:key :value | value = id ifTrue: [^key]].
	^nil
)
public recordFirst: presenter = (
	(* The popstate event has a null id when navigating all the way back. *)
	ids at: presenter put: nil.
)
public registerNewPresenter: newPresenter <Presenter>  = (
  | oldPresenter <Presenter> = equalVisitOr: newPresenter. |
(*  ('Registering presenter ', newPresenter printString) out.*)
  oldPresenter == newPresenter 
     ifTrue: [ 
(*	   'old and new presenters are identical' out. *)
	   idFor: newPresenter
	] 
     ifFalse: [ | id <Number> = idFor: oldPresenter.|
	  newPresenter updateVisualsFrom: oldPresenter.
(*	  'Updated visuals' out. *)
	  ids removeKey: oldPresenter.
	  ids at: newPresenter put: id.
	].
)
public resetSubjects = (
  allVisits do: [:v | v resetSubject]
)
) : (
)
class PaddedFrameComposer content: c offsets: o = Composer (|
	public content = c.
	offsets = o.
	public color
|) (
public childrenDo: aBlock = (
	nil = content ifFalse: [aBlock value: content]
)
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style')
		at: 'paddingLeft' put: (offsets at: 1) printString, 'px';
		at: 'paddingTop' put: (offsets at: 2) printString, 'px';
		at: 'paddingRight' put: (offsets at: 3) printString, 'px';
		at: 'paddingBottom' put: (offsets at: 4) printString, 'px'.
	color isNil ifFalse: [color applyToStyle: (div at: 'style')].
	content parent: self.
	div appendChild: content visual.
	^div
)
public isKindOfPaddedFrameComposer ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfPaddedFrameComposer
)
updateVisualsFromSameKind: oldFragment <PaddedFrameComposer> ^ <Alien[Element]> = (
  content parent: self.
  content updateVisualsFrom: oldFragment content.
  ^oldFragment visual
)
) : (
)
public class Presenter onSubject: aSubject <Subject> = Fragment (
(*
Subclasses of Presenter must implement the method #isMyKind:.

Stateful presenters require extra care. In some cases, they may have to override #updateVisualsFromSameKind: so that
the relevant state is preserved when the GUI is updated.

Care must also be taken for any subpresenters used by a presenter. If a subpresenter is used in multiple parts of a definition,
distinct copies may be computed unless the subpresenter is explicitly cached. These copies may get out of sync causing bugs,
depending on how they are used.  
*)
|
public subject <Subject> ::= aSubject.
substanceSlot <Fragment>
|) (
public = anotherPresenter = (
(* Underlying this model are assumptions about Presenter equality; 
   two presenters are equal iff they are of the same class and have equal subjects. 
*)
	^(isMyKind: anotherPresenter) and: [anotherPresenter subject = subject]
)
alert: text = (
	window alert: text
)
blank: size = (
	^BlankFragment new size: size
)
button: label <String> action: block <[]> = (
	^ButtonFragment label: label action: block
)
canvas: extent <Point> = (
	^CanvasFragment withExtent: extent
)
public childrenDo: aBlock = (
	nil = substanceSlot ifFalse: [aBlock value: substanceSlot]
)
codeMirror: t <Text | String> = (
	^CodeMirrorFragment onText: t
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> ^<Fragment> = (
	^collapsed: collapsed expanded: expanded initiallyExpanded: false
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean>
^<ToggleComposer> = (
	^ToggleComposer
		collapsedDefinition: collapsed
		expandedDefinition: expanded
		initiallyExpanded: flag
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> initiallyExpanded: flag <Boolean> tag: t <String>
^<ToggleComposer> = (
	^(ToggleComposer
		collapsedDefinition: collapsed
		expandedDefinition: expanded
		initiallyExpanded: flag)
		tag: t;
		yourself
)
collapsed: collapsed <[Fragment]> expanded: expanded <[Fragment]> tag: t <String> ^<Fragment> = (
	^collapsed: collapsed expanded: expanded initiallyExpanded: false tag: t
)
column: definitions <List[Fragment]> ^ <ColumnComposer> = (
	^ColumnComposer definitions: definitions
)
createVisual ^ <Alien[HTMLElement]> = (
   ^substance visual
)
deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: nothing contentSource: contentSource
)
public definition ^<Fragment> = (
	subclassResponsibility
)
dropDownMenu: menu <[Menu]> ^ <DropDownMenuFragment> = (
	^DropDownMenuFragment menu: menu
)
dropDownMenu: menu <[Menu]> alignment: side <Symbol> ^ <DropDownMenuFragment> = (
	^DropDownMenuFragment menu: menu alignment: side
)
dropDownMenu: menu <[Menu]> images: ims <Array[Image]>  ^ <DropDownMenuFragment> = (
	^DropDownMenuFragment menu: menu images: ims
)
dropDownMenu: menu <[Menu]> images: ims <Array[Image]> alignment: side <Symbol> ^ <DropDownMenuFragment> = (
	^DropDownMenuFragment menu: menu images: ims alignment: side
)
elastic: aFragment = (
	aFragment elasticity: 1.
	^aFragment
)
ensureSubstance = (
	nil = substanceSlot ifTrue:
		[substanceSlot:: self definition.
		substanceSlot parent: self.
		noticeSubstanceCreation]
)
enterSubject: s = (
	(* TODO: use sendUp and open a new window if undelivered *)
	^shell enterSubject: s
)
enterSubject: s <Subject> fromSnippet: snippet <SnippetSubject> = (
	(* TODO: use sendUp and open a new window if undelivered *)
	^shell enterSubject: s fromSnippet: snippet
)
expanded: expanded <[Fragment]> collapsed: collapsed <[Fragment]> ^<Fragment> = (
	^collapsed: collapsed expanded: expanded initiallyExpanded: true
)
filler = (
	^BlankFragment new expansibility: 1; compressibility: 1
)
hasSubstance ^<Boolean> = (
	^nil ~= substanceSlot
)
public hash = (
	^subject hash
)
holder: def <Fragment | [Fragment]> = (
	^HolderComposer withContent: def
)
image: image = (
	^StaticImageFragment image: image
)
imageButton: images <Array[Image]> action: block <[]> = (
	^ImageButtonFragment images: images action: block
)
initially: initialContent <Fragment> deferred: contentSource <[Fragment]> ^<Fragment> = (
	^DeferredContentComposer initialContent: initialContent contentSource: contentSource
)
public isKindOfPresenter ^ <Boolean> = (
  ^true
)
public isTransient = (
	(* Should visits of this presenter be omitted from the navigation history? *)
	^false
)
label: label <String> = (
	^StaticLabelFragment text: label
)
link: label <String> action: block <[]> = (
	^HyperlinkFragment label: label action: block
)
linkImage: image action: block = (
	^HyperlinkImageFragment image: image action: block
)
list ^ <PresenterList> = (
	^PresenterList new
)
list: presenterSource <Sequence[Presenter] | [Sequence[Presenter]]> ^ <PresenterList> = (
	^PresenterList new presenterSource: presenterSource
)
mediumBlank = (
	^blank: 10
)
menuWithLabelsAndActions: labelsAndActions <Tuple[Symbol | Tuple[String, []]]> ^ <Menu> = (
	| menu |
	^labelsAndActions

(*	menu:: Menu forVisual: visual.
	labelsAndActions do:
		[:each |
		menu add: (#separator = each
			ifTrue: [SeparatorItem new]
			ifFalse: [MenuItem key: nil label: each key action: each value])].
	^menu *)
)
nothing = (
	^BlankFragment new
)
noticeSubstanceCreation = (
	(* Received after the #definition method of the receiver has been invoked and the result remembered as its substance. The substance hasn't been asked to create a visual yet. *)
)
openMenu: aMenu <Menu> ^ <Alien[Div]> = (
	| menuContent <Alien[Div]> |
	menuContent:: computeContentForMenu: [aMenu].
	(menuContent at: 'style') at: 'display' put: 'block'.
	visual appendChild: menuContent.
	menuContent addEventListener: 'click' action:
		[:event | visual removeChild: menuContent. nil].
	^menuContent
(* so the issue here is to actually open a menu that was not in the tree before? And how to close it*)
)
openMenuWithLabelsAndActions: labelsAndActions = (
	openMenu: (menuWithLabelsAndActions: labelsAndActions)
)
padded: def with: offsets = (
	^PaddedFrameComposer content: def offsets: offsets
)
public refreshmentPresenter ^ <Self> = (
  | newPresenter <Presenter> ::= subject presenter. |
(*  ('Refreshing presenter ', printString, ' to ', newPresenter printString) out.*)
  (* subject was not reset;  I am semantically vaild *)
  newPresenter == self ifTrue: [^self.]. 
  (isMyKind: newPresenter) ifTrue: [
(*	  'Standard presenter' out.*)
	(* subject was reset, and its presenter is the correct replacement *)
	shell registerNewPresenter: newPresenter. (* register and return *)
	^newPresenter
	].
 (* I am not the subject's standard kind of presenter *)
(*  'Non-standard presenter' out.*)
  newPresenter:: class onSubject: subject. (* create a new instance of my class *)
  shell registerNewPresenter: newPresenter. (* register and return *)
  ^newPresenter
)
public resetSubject = (
  subject resetPresenters
)
row: definitions = (
	^RowComposer definitions: definitions
)
schedule: action <[]> = (
	window setTimeout: [action value. nil] with: 0.
)
public substance ^ <Fragment> = (
	ensureSubstance.
	^substanceSlot
)
text: t <Text> = (
	| subfragments <Collection[Fragment]> |
	t isKindOfTextString ifTrue: [^TextStringFragment onText: t].
	subfragments:: t textUnits collect: [:u <Text> | text: u].
	^TextBlockFragment onText: t subfragments: subfragments
)
textDisplay: string = (
	^TextDisplayFragment text: string
)
textField: initialText onAccept: blk = (
(* experimental *)
	 ^fragments TextEditorFragment new
	  text: initialText;
	  acceptResponse: blk (*[:editor | blk valueWithPossibleArgument: editor. editor defaultAcceptResponse] *)
)
textString: string <String> = (
	^TextStringFragment forString: string
)
textString: string <String> properties: tps <TextProperties> = (
	^TextStringFragment forString: string properties: tps
)
public title ^<String> = (
	^subject title
)
toggleList: ts <Sequence[ToggleComposer]> ^ <ToggledList> = (
  ^ToggledListFragment ofToggles: ts
)
updateVisualsFromSameKind: oldPresenter <Self> ^ <Alien[Element]> = (
(* A Presenter's visual is determined by its substance, so by default we 
   update the substance from the old presenter's substance.
   Subclasses may need to override or extend this behavior if the presenter has state
  or if there are semantic reasons that make correlating the substances
  difficult or impossible.
*)
  substance updateVisualsFrom: oldPresenter substance.
 ^substance visual
)
zebra: sequence <Sequence[Fragment]> ^ <Sequence[Fragment]> = (
	sequence addDecorator: ZebraDecorator lighterColorFirst.
	^sequence
)
) : (
)
class PresenterList = Fragment (
(* PresenterList is a fragment that manages a sequence of Presenters, displaying them as a column. The interesting functionality it provides beyond that is updating itself intelligently when receiving a new sequence of presenters to display. New presenters equal (as determined by #=) to those currently displayed remain displayed as before, with any state they had unaffected even if their order in the list has changed.

The presenters can be given to the list either as a collection or as a niladic block that evaluates to a collection. In the latter case, a PresenterList will re-evaluate the block and update itself from the result each time it receives the #refresh message.

Slots:

presenterSourceX. The presenters to display or the block providing them, as given to this instance when it was created.

presentersX. If presenterSourceX is a collection, this slot holds the same object as presenterSourceX. It it is the block, it holds the last result produced by the block.
*)
|
	presenterSourceX <Sequence[Presenter] | [Sequence[Presenter]]> ::= List new.
	presentersX <Sequence[Presenter]>
|) (
public add: aPresenter <Presenter> = (
	(* Append the argument to the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)
	
	| newPresenters |
	newPresenters:: List withAll: presenters.
	(newPresenters includes: aPresenter) ifTrue:
		[newPresenters remove: aPresenter].
	newPresenters add: aPresenter.
	setPresenters: newPresenters.
)
public add: aPresenter <Presenter> afterIndex: index <Integer> = (
	| newList |
	newList:: presenters copy.
	newList add: aPresenter afterIndex: index.
	presenters: newList.
)
public addAll: additionalPresenters <{Presenter}> = (
	| newPresenters |
	newPresenters:: List withAll: presenters.
	newPresenters addAll: additionalPresenters.
	setPresenters: newPresenters.
)
public addFirst: aPresenter <Presenter> = (
	(* Add the argument at the beginning of the end of the list of displayed presenters. If there is an equal presenter already displayed, remove it. *)
	| newPresenters |
	newPresenters:: List withAll: presenters.
	(newPresenters includes: aPresenter) ifTrue:
		[newPresenters remove: aPresenter].
	newPresenters addFirst: aPresenter.
	setPresenters: newPresenters.
)
public childrenDo: aBlock = (
	nil = presentersX ifFalse: [presentersX do: aBlock].
)
public color: aColor = (
	addDecorator::
		ColorDecorator new color: aColor
)
createVisual = (
	| column = ColumnComposer definitions: presenters. |
	column parent: self.
	^column visual
)
public detectPresenter: aBlock = (
	^presentersX detect: aBlock
)
public detectPresenter: aBlock ifNone: noneBlock = (
	^presentersX detect: aBlock ifNone: noneBlock
)
findFirst: aBlock = (
	(* Answer the index of my first element for which aBlock evaluates as true. *)
	^presentersX findFirst: aBlock
)
findLast: aBlock = (
	(* Answer the index of my last element for which aBlock evaluates as true. *)
	^presentersX findLast: aBlock
)
public presenterSource: niladicValuable <Sequence[Presenter] | [Sequence[Presenter]]> = (
	presenterSourceX:: niladicValuable.
	nil = presentersX ifFalse: [refreshPresenterList].
)
public presenters ^ <Sequence[Presenter]> = (
	(* Return the presenters we are currently showing, pulling them from the source if needed. *)

	nil = presentersX ifTrue:
		[setPresenters: (presenterSourceX isKindOfClosure
			ifTrue: [presenterSourceX value]
			ifFalse: [presenterSourceX])].
	^presentersX
)
public presenters: newPresenterList <Sequence[Presenter]> = (
	self presenterSource: newPresenterList
)
public refresh = (
	| newPresenters |
	newPresenters:: Set withAll: refreshPresenterList.
	presenters do:
		[:each | (newPresenters includes: each) ifFalse: [each refresh]]
)
refreshPresenterList = (
	(* Make it so that the displayed presenters match those provided by the source. For a list initialized with a presenter collection, this only does anything non-trivial when the instance is brand new. For a list initialized with a block, this re-evaluates the block and updates the list. *)
	| newPresenters |
	newPresenters:: presenterSourceX isKindOfClosure
		ifTrue: [presenterSourceX value]
		ifFalse: [presenterSourceX].
	^setPresenters: newPresenters
)
refreshPresenters = (
	presenters do: [:each | each refresh]
)
public remove: aPresenter = (
	| newPresenters |
	newPresenters:: List withAll: presenters.
	newPresenters remove: aPresenter.
	setPresenters:: newPresenters.
)
public removeAt: index <Integer> = (
	| copy |
	copy:: presenters copy.
	copy removeAt: index.
	presenters:: copy.
)
replaceChild: aFragment with: anotherFragment = (
	| index newPresenters |
	(presentersX includes: aFragment) ifTrue:
		[index:: presenters indexOf: aFragment.
		newPresenters:: presenters copy.
		newPresenters at: index put: anotherFragment.
		^presenters: newPresenters].
	error: 'the fragment is not a child'
)
public setPresenters: newPresenterList <Sequence[Presenter]> = (
	(* This is the workhorse of intelligent updates: massage the argument presenters into the currently displayed list, making sure that if there is an element of newPresenterList equal to a currently displayed presenter, we continue using the current presenter. *)

	| currentPresenters oldPresentersAndIndices removedPresenters removedIndices addedPresenters newFinalList |
	currentPresenters:: nil = presentersX ifTrue: [List new] ifFalse: [presentersX].
	oldPresentersAndIndices:: Map new: currentPresenters size.
	currentPresenters keysAndValuesDo:
		[:index :each | oldPresentersAndIndices at: each put: index].
	addedPresenters:: List new: newPresenterList size.
	newFinalList:: List new: newPresenterList size.

	newPresenterList do:
		[:each | | oldIndex |
		oldIndex:: oldPresentersAndIndices at: each ifAbsent: [nil].
		nil = oldIndex
			ifFalse: (* reusing a presenter we already have for this subject *)
				[newFinalList add: (presenters at: oldIndex).
				oldPresentersAndIndices removeKey: each]
			ifTrue:
				[newFinalList add: each.
				addedPresenters add: each]].

	removedPresenters:: oldPresentersAndIndices keys.
	(* removedIndices:: (1 to: currentPresenters size) select:
		[:index | removedPresenters includes: (currentPresenters at: index)]. *)

	presentersX:: newFinalList.
	presenterSourceX:: newFinalList.
	addedPresenters do: [:each <Presenter> | each parent: self].
	hasVisual ifTrue: [updateColumn].
	(*	[updateColumn: visualX
		 removingIndices: removedIndices
		 addingPresenters: addedPresenters].*)
	^addedPresenters
)
updateColumn = (
	| newVisual = createVisual. |
  (visual at: 'parentElement') replaceChild: newVisual with: visual.
(* Note: this really means replace visual with newVisual; JS takes the args in wrong order *)
  visualX: newVisual
)
updateColumn: column removingIndices: indices addingPresenters: newPresenters = (
	indices asSortedList reverseDo:
		[:each | column removeAt: each].
	newPresenters do:
		[:each | column add: each visual].
	column reorder:
		(presenters collect: [:each | each visual])
)
) : (
)
class RowComposer definitions: fs <List[Fragment]> = SequenceComposer definitions: fs (
) (
flexDirection ^ <String> = (
	^'row'
)
public isKindOfRowComposer ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfRowComposer
)
) : (
)
class SequenceComposer definitions: fs <List[Fragment]> = Composer (|
	public definitions <List[Fragment]> = fs.
	public color <Color>
	protected alignItems ::= 'center'.
	protected childAlignSelf ::= 'center'.
	protected justifyContent ::= 'flex-start'.
|) (
alignFragment: fragment  <Fragment> = (
	| cell <Alien[HTMLElement]> |
	cell:: fragment visual.
	(cell at: 'style')
		at: 'overflow' put: 'hidden';
		at: 'align-self' put: childAlignSelf;
		at: 'flex-grow' put: fragment expansibility;
		at: 'flex-shrink' put: fragment compressibility.
	nil = fragment size ifFalse:
		[(cell at: 'style')
			at: 'flex-basis' put: fragment size printString, 'px'].
)
public childrenDo: aBlock = (
	definitions do: aBlock
)
createVisual ^ <Alien[HTMLElement]> = (
	| container <Alien[HTMLElement]> |
	container:: document createElement: 'div'.
	(container at: 'style')
		at: 'overflow' put: 'hidden';
		at: 'display' put: 'flex';
		at: 'flex-direction' put: flexDirection; (* where does flexDirection come from? *)
		at: 'align-content' put: alignItems;
		at: 'justify-content' put: justifyContent.
	nil = color ifFalse:
		[color applyToStyle: (container at: 'style')].
	definitions do: [:fragment <Fragment> |
		fragment parent: self.
		alignFragment: fragment.
		container appendChild: fragment visual].
	^container
)
public crossAxisAlignToCenter = (
	alignItems:: 'center'.
	childAlignSelf:: 'center'.
)
public crossAxisAlignToEnd = (
	alignItems:: 'flex-end'.
	childAlignSelf:: nil.
)
public crossAxisAlignToStart = (
	alignItems:: 'flex-start'.
	childAlignSelf:: nil.
)
public crossAxisStretch = (
	alignItems:: 'stretch'.
	childAlignSelf:: nil.
)
flexDirection ^ <String> = (
  subclassResponsibility
)
public mainAxisAlignToCenter = (
	justifyContent:: 'center'.
)
public mainAxisAlignToEnd = (
	justifyContent:: 'flex-end'.
)
public mainAxisAlignToStart = (
	justifyContent:: 'flex-start'.
)
updateVisualsFromSameKind: oldFragment <SequenceComposer> ^ <Alien[Element]> = (
  | size <Integer> = definitions size. |
(* We cannot, in general, know whether the elements of the sequence correlate
    However, if the sequences have the same length they might. 
 *)
  size = oldFragment definitions size ifTrue: [
	(* Assume the common case: elements are in 1:1 correspondence. *)
	1 to: size do: [:i <Integer> | 
		| def = definitions at: i. |
		def parent: self.
		def updateVisualsFrom: (oldFragment definitions at: i).
		alignFragment: def.
		].
	^oldFragment visual
	].
  (* If the sizes differ, the oldFragment was not produced by the same code and we will compute our visual from scratch *)
  ^replaceVisual: oldFragment visual with: visual
)
) : (
)
class StaticImageFragment image: i = LeafFragment (|
	public image = i.
|) (
createVisual = (
	| div img |
	div:: document createElement: 'div'.
	(div at: 'style')
		at: 'display' put: 'flex';
		at: 'flex-direction' put: 'flex-column';
		at: 'align-items' put: 'center'.
	img:: image cloneNode: false. (* Not deep *)
	div appendChild: img.
	^div
)
public isKindOfStaticImageFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfStaticImageFragment
)
updateVisualsFromSameKind: oldFragment <Fragment> = (
  | oldVisual = oldFragment visual. |
  oldFragment image ~= image ifTrue: [
	oldVisual replaceChild: ( image cloneNode: false) replacing: (oldVisual at: 'firstChild').
	].
  ^oldVisual
)
) : (
)
class StaticLabelFragment text: t = LeafFragment (|
	textX ::= t.
	public color
|) (
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style')
		at: 'overflow' put: 'hidden';
		at: 'white-space' put: 'pre'.
	div at: 'textContent' put: text.
	nil = color ifFalse:
		[(div at: 'style') setProperty: 'color' to: color asCSSString].
	^div
)
public isKindOfStaticLabelFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfStaticLabelFragment
)
public smallFont = (
	(visual at: 'style') at: 'font-size' put: 'smaller'
)
public text = (
	^textX
)
public text: newText = (
	textX: newText.
	hasVisual ifTrue: [visual at: 'textContent' put: textX]
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^replaceVisual: oldFragment visual with: visual (* optimize later? Does it even matter? *)
)
) : (
)
public class Subject onModel: aModel = (
(*
Subjects implement application semantics. 

By default, subjects are equal if they are of the same kind and have equal models. It is sometimes necessary to override equality (and hash).

Subclasses should implement isMyKind:.

In some cases one must override resetPresenters. This is crucial in cases where there are sub-subjects. These subjects will not be reset by the UI framework unless  resetPresenters calls resetPresenter on them recursively.
*)
|
	public model = aModel.
	protected presenterX <Presenter>
|) (
public = anotherSubject ^<Boolean> = (
  ^(isMyKind: anotherSubject) and: [model = anotherSubject model].
)
public createPresenter ^<Presenter> = (
	subclassResponsibility
)
public hash ^ <Integer> = (
  ^model hash
)
isMyKind: s <Subject> ^ <Boolean> = (
  subclassResponsibility
)
public presenter ^<Presenter> = (
	presenterX isNil ifTrue: [presenterX:: createPresenter].
	^presenterX
)
public refreshmentSubject ^<Subject> = (
	(* Answer a new subject representing the same thing as the receiver. *)
	^self class onModel: model
)
public resetPresenters = (
   presenterX:: nil.
)
public title ^<String> = (
	^self printString
)
) : (
)
class TextBlockFragment onText: t <Text> subfragments: sfs <List[Fragment]> = TextFragment onText: t (
(* A fragment representing a compound text . *)
| subfragments <List[Fragment]> = sfs. |) (
createVisual = (
	| span = document createElement: 'span'. |
	text textProperties applyTo: span.
	subfragments do: [:u |
		span insertAdjacentElement: 'beforeEnd' into: u visual
		].
	^span
)
public cursorPosition ^ <Integer> = (
 |
  ca
  sel = window getSelection.
  focusNode
  sum <Integer> ::= 0.
 |
  sel isNil ifFalse: [ (*BOGUS: assumes the block is a flat collection of TextStringFragments*)
	focusNode:: sel at: 'focusNode'.
	ca:: (sel getRangeAt: 0) at: 'commonAncestorContainer'.
	subfragments do: [:sf <Fragment> |
		(sf visual at: 'firstChild') = focusNode ifTrue: [^sum + sf cursorPosition].
	  sum:: sum + (sf visual at: 'textContent') size.
		].
	].
	^nil
)
public cursorPosition: position <Integer> = (
	| sum <Integer> ::= 0. |
(*BOGUS: assumes the block is a flat collection of TextStringFragments*)
	subfragments do: [:subfragment <Fragment> | | index <Integer> |
		index:: position  - sum.
		sum:: sum + (subfragment visual at: 'textContent') size.
		position <= sum ifTrue: [subfragment cursorPosition: index. ^self].
		].
)
public isKindOfTextBlockFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTextBlockFragment
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^replaceVisual: oldFragment visual with: visual (* optimize later? Does it even matter? *)
)
) : (
)
class TextDisplayFragment text: t = LeafFragment (|
	textX ::= t.
|) (
createVisual = (
	| div = document createElement: 'div'. |
	(div at: 'style') setProperty: 'white-space' to: 'pre-wrap'.
	div at: 'textContent' put: textX.
	^div
)
public isKindOfTextDisplayFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTextDisplayFragment
)
public smallFont = (
  (visual at: 'style') at: 'font-size' put: 'smaller'
)
public text = (
	^textX
)
public text: newText = (
	textX: newText.
	hasVisual ifTrue: [visual at: 'textContent' put: textX]
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^replaceVisual: oldFragment visual with: visual (* optimize later? Does it even matter? *)
)
) : (
)
public class TextEditorFragment = LeafFragment (|
	textX <TextFragment | String> ::= ''.
	counterfactualBarX
	editorX <Div>
	public textBeingAccepted <String>
	isInEditState ::= false.
	public changeResponse <[TextEditorFragment]>
	public acceptResponse <[TextEditorFragment]>
	public cancelResponse <[TextEditorFragment]>
	public oldText <TextFragment | String>
|) (
controlBarColor = (
	^Color r: 0.95 g: 0.792 b: 0.475
)
createVisual = (
	| frame editorWrapper accept cancel |
	frame:: document createElement: 'div'.
	(frame at: 'style')
		at: 'display' put: 'flex'.
	editorX:: document createElement: 'div'.
	editorX at: 'contentEditable' put: 'true'.
	(editorX at: 'style')
		at: 'borderStyle' put: 'solid';
		at: 'borderWidth' put: '1px';
		at: 'borderColor' put: 'gray';
		setProperty: 'background-color' to: 'white';
		at: 'flex' put: 1;
		setProperty: 'white-space' to: 'pre-wrap';
		at: 'display' put: 'block'.
		setText: textX.
	(* editorX at: 'textContent' put: textX.*)
	editorX addEventListener: 'input' action: [:event | respondToChange: event. nil].
	counterfactualBarX:: document createElement: 'span'.
	(counterfactualBarX at: 'style')
		at: 'backgroundColor' put: controlBarColor asCSSString;
		at: 'flex' put: 'none'.
	accept:: document createElement: 'img'.
	accept at: 'src' put: (accept16px yourself at: 'src').
	(accept at: 'style') at: 'margin' put: '3px'.
	accept at: 'onclick' put: [:event | respondToAccept: event. nil].
	cancel:: document createElement: 'img'.
	cancel at: 'src' put: (cancel16px yourself at: 'src').
	(cancel at: 'style') at: 'margin' put: '3px'.
	cancel at: 'onclick' put: [:event | respondToCancel. nil].
	counterfactualBarX appendChild: accept.
	counterfactualBarX appendChild: cancel.
	frame appendChild: editorX.
	(* frame appendChild: counterfactualBarX. *)
	^frame
)
public cursorPosition ^ <Integer> = (
(* BOGUS. This leads to quirks when cutting and pasting. We really need to get the selection from the browser and identify
the cursor position based on that. But so far that hasn't worked. And we have issues with inserting newlines.
*)
	|
	oldString <String>
	newString <String>
	bound <Integer>
	offset <Integer> ::= 0.
	|
	oldString:: textX text string.
	newString:: textBeingAccepted.
	bound:: newString size min: oldString size.
	offset:: -1 max: (newString size - oldString size - 1).
	('old: ', oldString) out.
	('new: ', newString) out.
	1 to: bound do: [:i <Integer> |
		(oldString at: i) = (newString at: i) ifFalse: [^i + offset]
		].
	^newString size
)
public defaultAcceptResponse = (
	setVisualText: textBeingAccepted.
	leaveEditState
)
defaultCancelResponse = (
	setVisualText: textX.
	leaveEditState
)
defaultChangeResponse = (
	enterEditState
)
public enterEditState = (
	isInEditState ifFalse:
		[visual appendChild: counterfactualBarX.
		isInEditState:: true].
	visual scrollIntoView: true (* alignWithTop *).
)
public isKindOfTextEditorFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTextEditorFragment
)
public leaveEditState = (
	isInEditState ifTrue:
		[visualX removeChild: counterfactualBarX.
		isInEditState:: false.
		(*removeMessages*)]
)
reconstructText ^ <String> = (
  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect
	newlines, as these are sometimes implied by div and br nodes. *)
 |
  children <Alien[HTMLCollection]> = editorX at: 'children'.
  numberOfChildren = children at: 'length'.
  result <String>
 |
	numberOfChildren = 0 ifTrue: [^textBeingAccepted:: editorX at: 'textContent'].
	result:: ''.
	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].
	^result
)
reconstructTextForNode: n <Alien[Node]> ^ <String> = (
  (* compute the text string from the DOM. This is necessary since the textContent attribute does not accurately reflect
	newlines, as these are sometimes implied by div and br nodes. *)
 |
  children <Alien[HTMLCollection]> = n at: 'children'.
  numberOfChildren = children at: 'length'.
  result <String>
 |
	result:: ''.
	numberOfChildren = 0  ifTrue: [result:: n at: 'textContent'].
	0 to: numberOfChildren - 1 do: [:i <Integer> | result:: result, (reconstructTextForNode: (children item: i))].
	({'P'. 'BR'. 'DIV'} includes: (n at: 'tagName') ) ifTrue: [(n at: 'tagName') out. result:: result, String cr].
	^result.
)
respondToAccept: event <Alien[Event]> = (
	textBeingAccepted:: reconstructText (*editorX at: 'textContent'.*)(*withSqueakLineEndings*).
	nil = acceptResponse
		ifTrue: [defaultAcceptResponse]
		ifFalse: [acceptResponse cull: self cull: event]
)
respondToCancel = (
	(*confirm: 'Confirm Cancel' ifConfirmed:
		[*)nil = cancelResponse
			ifTrue: [defaultCancelResponse]
			ifFalse: [cancelResponse cull: self](*]*)
)
respondToChange: event <Alien[Event]> = (
	textBeingAccepted:: reconstructText (*editorX at: 'textContent'.*).
	nil = changeResponse
		ifTrue: [defaultChangeResponse]
		ifFalse: [changeResponse cull: self cull: event]
)
public setCursor = (
	| sum <Integer> ::= 0. cp <Integer> = cursorPosition. |
	cp out.
	textX cursorPosition: 5.
	(* textX elementaryTextUnits do: [:u <TextString> | (*textX is a fragment or a string, has no elementary text units*)
		sum:: sum + u string size.
		cp < sum ifTrue: [^setCursor: u to: cp]
		]*)
)
public setCursor: position <Integer> = (
	| sum <Integer> ::= 0. |
	position out.
	textX cursorPosition: position.
)
setText: t <TextFragment | String> = (
   t isKindOfString
	ifTrue: [editorX at: 'textContent' put: t]
	ifFalse: [ | children = List new. |
		oldText isKindOfString ifFalse: [
			(editorX at: 'childNodes') forEach: [:n | children add: n].
			children do: [:n | editorX removeChild: n].
			].
		editorX appendChild: t visual
		]
)
setVisualText: aText = (
	hasVisual ifTrue: [setText: aText]
)
public showMessage: m = (
#BOGUS.
	m out
)
public text = (
	^textX
)
public text: t = (
	oldText:: textX.
	textX: t.
	setVisualText: textX.
)
public updateCursor = (
	| sum <Integer> ::= 0. cp <Integer> = textX cursorPosition. |
	textX cursorPosition: cp.
)
) : (
)
class TextFragment onText: t <Text> = Fragment (
(*Abstract supertype of all texts.*)
|
	public text <Text> = t.
|) (
public cursorPosition: position <Integer> = (
	subclassResponsibility
)
public isKindOfTextFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTextFragment
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^replaceVisual: oldFragment visual with: visual (* optimize later? Does it even matter? *)
)
) : (
)
class TextStringFragment onText: t <Text> = TextFragment onText: t (
(*A formatted string.*)
) (
public createVisual = (
	| span = document createElement: 'span'. |
	text textProperties applyTo: span.
	span at: 'textContent' put: text string.
	^span
)
public cursorPosition ^ <Integer> = (
 | sel = window getSelection. |
  sel isNil ifFalse: [
	(*(visual at: 'firstChild') = (sel at: 'focusNode') ifTrue: [*)
		^(sel getRangeAt: 0) at: 'endOffset'
		(*]*)
	].
  'textStringFragment cursorPosition is nil!' out.
	^nil
)
public cursorPosition: position <Integer> = (
 | textNode = visual at: 'firstChild'. range = document createRange. |

  range setStart: textNode to: position;
	  setEnd: textNode to: position.
  window getSelection removeAllRanges; addRange: range
)
public isKindOfTextStringFragment ^ <Boolean> = (
	^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfTextStringFragment
)
updateVisualsFromSameKind: oldFragment <Fragment> ^ <Alien[Element]> = (
  ^replaceVisual: oldFragment visual with: visual (* optimize later? Does it even matter? *)
)
) : (
public forString: s <String> ^ <Instance> = (
	^onText: (TextString forString: s properties: TextProperties new)
)
public forString: s <String> properties: tps <TextProperties> ^<Instance> = (
	^onText: (TextString forString: s properties: tps)
)
)
class ToggleComposer collapsedDefinition: collapsed <[Fragment]>
 expandedDefinition: expanded <[Fragment]>
 initiallyExpanded: flag <Boolean> = Composer (
|
expandedDefinition <[Fragment]> = expanded.
collapsedDefinition <[Fragment]> = collapsed.
public isExpanded <Boolean> ::= flag.
public expandedPresenter <Fragment>
public collapsedPresenter <Fragment>
public contentHolder <Alien[Div]>
toggleWidget <Alien[Img]>
public tag <String> ::= ''.
|) (
public childrenDo: aBlock = (
	nil = collapsedPresenter ifFalse:
		[aBlock value: collapsedPresenter].
	nil = expandedPresenter ifFalse:
		[aBlock value: expandedPresenter].
)
public collapse = (
	isExpanded:: false.
	installCollapsedPresenter
)
createVisual = (
	| toggleDiv <Alien[Div]> div <Alien[Div]> |
	contentHolder:: document createElement: 'div'.

	toggleDiv:: document createElement: 'div'.
	toggleWidget:: document createElement: 'img'.
	updateToggle: [:event | toggle. nil].
	toggleDiv appendChild: toggleWidget.

	(contentHolder at: 'style')
		setProperty: 'flex-grow' to: 1;
		setProperty: 'flex-shrink' to: 1.
	(toggleDiv at: 'style')
		setProperty: 'flex-grow' to: 0;
		setProperty: 'flex-shrink' to: 0;
		at: 'paddingTop' put: '2px';
		at: 'paddingRight' put: '3px'.
	toggleWidget at: 'align' put: 'top'.

	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].

	div:: document createElement: 'div'.
	(div at: 'style')
		at: 'display' put: 'flex';
		setProperty: 'flex-direction' to: 'row'.
	div appendChild: toggleDiv.
	div appendChild: contentHolder.
	^div
)
ensureCollapsedPresenter = (
	collapsedPresenter isNil ifTrue:
		[collapsedPresenter:: collapsedDefinition value.
		collapsedPresenter parent: self].
)
ensureExpandedPresenter = (
	expandedPresenter isNil ifTrue:
		[expandedPresenter:: expandedDefinition value.
		expandedPresenter parent: self].
)
public expand = (
	isExpanded:: true.
	installExpandedPresenter
)
installCollapsedPresenter = (
      ensureCollapsedPresenter.
	installContentVisual: collapsedPresenter visual.
	collapsedPresenter noticeExposure.
	toggleWidget at: 'src' put: (disclosureClosedImage at: 'src').
)
installContentVisual: newVisual = (
	contentHolder hasChildNodes
		ifTrue:
			[ | oldVisual = contentHolder at: 'firstChild'. |
			contentHolder replaceChild: newVisual insteadOf: oldVisual] (* DOM API is stupid; it really replaces old with new *)
		ifFalse: [contentHolder appendChild: newVisual].
)
installExpandedPresenter = (
      ensureExpandedPresenter.
	installContentVisual: expandedPresenter visual.
	expandedPresenter noticeExposure.
	toggleWidget at: 'src' put: (disclosureOpenImage at: 'src').
)
public isKindOfToggleComposer ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfToggleComposer
)
public toggle = (
	isExpanded:: isExpanded not.
	isExpanded
		ifTrue: [installExpandedPresenter]
		ifFalse: [installCollapsedPresenter].
)
public updateToggle: toggleBlock <[Alien[Event]]> = (
	toggleWidget at: 'onclick' put: toggleBlock.
	^toggleWidget
)
updateVisualsFromSameKind: oldFragment <ToggleComposer> ^ <Alien[Element]> = (
  toggleWidget:: oldFragment updateToggle: [:event | toggle. nil].
  contentHolder:: oldFragment contentHolder.
  contentHolder isNil ifTrue: ['nil contentHolder during update', out].
  isExpanded:: oldFragment isExpanded.
  oldFragment expandedPresenter isNil ifFalse: [
	ensureExpandedPresenter.
	expandedPresenter updateVisualsFrom: oldFragment expandedPresenter
	].
  oldFragment collapsedPresenter isNil ifFalse: [
	ensureCollapsedPresenter.
	collapsedPresenter updateVisualsFrom: oldFragment collapsedPresenter
	].
  isExpanded
    ifTrue: [installExpandedPresenter]
    ifFalse: [installCollapsedPresenter].
  ^oldFragment visual
)
) : (
)
class ToggledListFragment ofToggles: ts <Sequence[ToggleComposer]> = Fragment  (
(* 
A column of toggle composers that we can intelligently update.
*)
|
	public toggles <Sequence[ToggleComposer]> = ts.
|
) (
public childrenDo: aBlock = (
	toggles do: aBlock
)
createVisual ^ <Visual> = (
  | col <ColumnComposer> = ColumnComposer definitions: toggles. |
  col parent: self.
  ^col visual
)
public isKindOfToggledListFragment ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfToggledListFragment
)
updateVisualsFromSameKind: oldFragment <Self> ^ <Alien[Element]> = (
(* In a toggled list, we can either patch the old one to include new things, drop deleted ones and update the contents of existing ones
   recursively, or we can patch the new one by updating the state of pre-existing toggles.
   Here, we do the latter.
*)
  | contentMap = Map new. |
  toggles do: [:e <ToggleComposer> |
	(* e tag out.*)
	 contentMap at: e tag put: e
	].
  oldFragment toggles do: [:op  <ToggleComposer> |
	(contentMap includesKey: op tag) ifTrue: [ 
		(* op tag out. *)
		(contentMap at: op tag) updateVisualsFrom: op
		]
	].
 ^replaceVisual: oldFragment visual with:  visual.
)
) : (
)
public class ZebraDecorator firstColor: color1 secondColor: color2 = Decorator (|
	firstColor ::= color1.
	secondColor ::= color2.
	sequenceDefinition
|) (
public decorate: aVisual = (
| odd <Boolean> ::= false.  children = (aVisual at: 'children'). |
	0 to: (children at: 'length') - 1 do:
		[:index | | each = children item: index. c <Color> |
		c:: odd ifTrue: [firstColor] ifFalse: [secondColor].
		assert: [c isNil not] message: ['nil color!'].
		c applyToStyle: (each at: 'style').
		odd:: odd not.
		].
	^aVisual
)
) : (
public darkerColorFirst = (
	^self firstColor: (Color gray: 0.97) secondColor: Color white
)
public lighterColorFirst = (
	^self firstColor: Color white secondColor: (Color gray: 0.97)
)
)
public CodeMirror = (
  ^window at: 'CodeMirror'.
)
allWindowsResetSubjects = (
  currentHopscotchWindow resetSubjects (*If we have more than one window, we need to revise this *)
)
computeContentForMenu: menuSupplier <[Menu]> ^ <Alien[Div]> = (
	| dropDownContent = document createElement: 'div'. |
	(dropDownContent at: 'style')
		at: 'color' put: 'black';
		at: 'backgroundColor' put: 'lightgray';
		at: 'position' put: 'absolute';
		at: 'z-index' put: 1;
		at: 'padding-left' put: '6px';
		at: 'padding-right' put: '10px';
		at: 'border-radius' put: '5px';
		at: 'box-shadow' put: '5px 5px 5px darkgrey';
		at: 'display' put: 'none'.
	menuSupplier value do: 
		[:menuItem <MenuItem | Symbol> |
		 | itemContent <Alien[Element]> |
		 itemContent:: contentFor: menuItem within: dropDownContent.
		 dropDownContent appendChild: itemContent].
	^dropDownContent
)
contentFor: menuItem < MenuItem | Symbol> within: dropDownContent ^ <Alien[Element]> = (
	| entry |
	menuItem = #separator ifTrue:
		[^document createElement: 'hr'].
	entry:: document createElement: 'div'.
	entry at: 'textContent' put: menuItem first.
	entry
		addEventListener: 'mouseover' action:
			[:event | (entry at: 'style') at: 'background-color' put: 'darkgrey'. nil];
	      addEventListener: 'mouseout' action:
			[:event | (entry at: 'style') at: 'background-color' put: 'lightgrey'. nil];
		addEventListener: 'click' action:
			[:event | menuItem last value. nil].
	^entry
)
deferAction: action = (
	deferredContentQueue add: action.
	deferredContentQueue size = 1 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
)
nextDeferredAction = (
	| action = deferredContentQueue removeFirst. |
	deferredContentQueue size > 0 ifTrue:
		[nextFrameDo: [nextDeferredAction]].
	action value.
)
nextFrameDo: action <[]> = (
	(* Our goal is to run the argument after images have been loaded and rendered. window.requestAnimationFrame runs the callback *before* the next frame. We register another callback in the callback so the first deferred action runs *after* the next frame. We register *that* callback in another RAF callback to let new images added from a deferred block load and render before the next deferred block runs. RAF is also a relative new feature, so simply schedule a timer if it is not available. *)
	(window at: 'requestAnimationFrame') isUndefined ifTrue:
		[Timer after: 200 do: action. ^self].

	window requestAnimationFrame:
		[:time1 <Float> | window requestAnimationFrame:
			[:time2 <Float> | window requestAnimationFrame:
				[:time3 <Float> | action value. nil]]].
)
sharedNavigator ^ <NavigationHistory> = (
	nil = sharedNavigationHistory ifTrue:
		[sharedNavigationHistory:: NavigationHistory new].
	^sharedNavigationHistory
)
updateAllWindows: action <[Object]> = (
  currentHopscotchWindow updateGUI: action  (*If we have more than one window, we need to revise this *)
)
) : (
)
