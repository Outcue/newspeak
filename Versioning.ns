Newspeak3
'OrthogonalSynchronization'
class Versioning usingPlatform: platform clientModule: aClientModule clientServerModule: aClientServerModule= (
|
	List = platform collections List.
	Map = platform collections Map.
	Set = platform collections Set.
	clientModule = aClientModule.
	clientServerModule = aClientServerModule.
	
|
) (
class AAVersionsDiffer from: aVersion to: anotherVersion  = (
|
	sourceVersion = aVersion.
	targetVersion = anotherVersion.
	commonAncestor
	changeRecords
	newObjectDefinitions
	
|
) (
class VersionsDiffResult changeRecords: aCollectionOfChangeRecords newObjects: aCollectionOfNewObjects = (
|
	public changeRecords = aCollectionOfChangeRecords.
	public newObjects=  aCollectionOfNewObjects.
|
) (
) : (
)
computeChangeFor: anObjectVersion = (
	| history |
	
	
		commonAncestor 
			versionById: anObjectVersion principalId 
			ifFound: [ :foundVersion  |	
		
					history:: ObjectVersionHistory from: anObjectVersion upTo: {foundVersion }. 
					changeRecords add:  (history resumedChangeRecord asObjectChangeRecordForId: anObjectVersion principalId).
		
			]
			ifNotFound: [
				history:: ObjectVersionHistory completeFor: anObjectVersion.
				newObjectDefinitions add: (clientServerModule ObjectDefinitionWithIdentification 
													id: anObjectVersion principalId 
													definition: history resumedChangeRecord).
		
			].
		
)
computeChangesForSameObjectFrom: sourceObjectVersion to: destObjectVersion  = (

	| lcas  history ca union cr |

	lcas:: (LeastCommonAncestorsFinder for: sourceObjectVersion and: destObjectVersion) value .
	union:: Set withAll: lcas.
	union add: destObjectVersion.
	
	cr:: (ObjectVersionHistory from: sourceObjectVersion upTo: union) resumedChangeRecord.
	changeRecords add: (cr asObjectChangeRecordForId: sourceObjectVersion principalId).
	^changeRecords

(*	| history ca |

	ca:: (SingleLeastCommonAncestorFinder for: sourceObjectVersion and: destObjectVersion) value .
	history:: ObjectVersionHistory from: ca to: sourceObjectVersion exclusion: [ :v | v == destObjectVersion ]. 
	changeRecords add:  (history resumedChangeRecord asObjectChangeRecordForId: sourceObjectVersion principalId).
*)	
	(*
	commonAncestor 
			versionById: anObjectVersion principalId 
			ifFound: [ :foundVersion  |	
		
					history:: ObjectVersionHistory from: foundVersion to: anObjectVersion. 
					changeRecords add:  (history resumedChangeRecord asObjectChangeRecordForId: anObjectVersion principalId).
		
			]
			ifNotFound: [
				history:: ObjectVersionHistory completeFor: anObjectVersion.
				newObjectDefinitions add: (clientServerModule ObjectDefinitionWithIdentification 
													id: anObjectVersion principalId 
													definition: history resumedChangeRecord).
		
			].	
	
	
	*)

)
public value = (
	|  versionsByIdInSource versionsByIdInTarget objectIdsToInclude   |


	newObjectDefinitions:: List new.
	changeRecords:: List new.

	commonAncestor:: (SingleLeastCommonAncestorFinder for: sourceVersion and: targetVersion) value.


	versionsByIdInSource:: sourceVersion newVersionsByIdUpTo:  commonAncestor.	
	versionsByIdInTarget:: targetVersion newVersionsByIdUpTo:  commonAncestor.
	
	objectIdsToInclude:: versionsByIdInSource keys difference: versionsByIdInTarget keys.
	objectIdsToInclude do: [ :each | 
		| version history |
		version:: versionsByIdInSource at: each.
		computeChangeFor: version.
	].

	true ifTrue: [
		
		objectIdsToInclude:: versionsByIdInSource keys intersection: versionsByIdInTarget keys.
		
		objectIdsToInclude do: [ :each |
			| vSource vDest  |
			vSource:: versionsByIdInSource at: each.
			vDest:: versionsByIdInTarget at: each.
			
			(vSource versionId ~=  vDest versionId) 
				ifTrue: [ computeChangesForSameObjectFrom: vSource to: vDest.   ].
		].
		
	].

	^ VersionsDiffResult 
				changeRecords: changeRecords  
				newObjects: newObjectDefinitions 

)
) : (
)
class CompoundVersionId principal: aPrincipalId version: aVersionId  = (
|
	principalId = aPrincipalId.
	versionId = aVersionId.
|
) (
) : (
)
public class DefinitionsToObjectVersionsMaterializer objectStore: aStore = ObjectsMaterializer objectStore: aStore (
|

|
) (
createInstanceFrom:   definitionWithId  = (
	| initialVersion  newVersion definition |
	
	initialVersion:: InitialVersion id: objectStore newGuid.

	definition:: definitionWithId definition.
	
	newVersion::  ObjectVersion withParent: initialVersion versionedData: nil.
	

(* 	definition enclosingObjectReference: (definition enclosingObjectReference asGlobalReferenceUsing: objectStore).  *)

	^ newVersion


)
fillNewInstance: anInstance fromDefinition: aDefinition = (

	anInstance versionedData: (aDefinition  asGlobalReferenceUsing: objectStore).
	
)
) : (
)
public class IdGenerator seed: aSeed nextIdBlock: aBlock = (
|
	lastValue ::= aSeed.
	nextIdBlock = aBlock.
|
) (
public newId = (
	lastValue::  nextIdBlock value: lastValue.
	^ lastValue.
)
) : (
)
public class InitialVersion id:  anId    = (
|
	
	public versionId = 0.
	public principalId	= anId.
	idGenerator = IdGenerator seed: 0 nextIdBlock: [:x | x + 1].
	public childVersions = List new.

 |
) (
public allAncestors = (
	^ Set new
)
public distanceToRoot = (
	^ 0
)
public firstVersion = (
	^ singleChild
)
public generateNextVersionId  = (
	^ idGenerator newId.
)
public hasChildVersionWithId: anId = (
	^ childVersions anySatisfy: [:x | x versionId = anId] 
)
public initialVersion  = (
	^ self.
)
public isParentOf: aVersion  = (
	^ childVersions first == aVersion
)
public newVersionsByIdUpTo: aVersion  = (
	^ Map new
)
public newVersionsDo: aBlock = (

)
public registerChild: aVersion = (
	childVersions add: aVersion.
)
public resumedChangeRecordsUpTo: x = (
	 ^ List new.
)
public singleChild = (
	^ childVersions anyOne
)
public versionById: anId ifFound: foundBlock ifNotFound: notFoundBlock  = ( 
	^ notFoundBlock value
)
public versionById: anId ifNotFound: notFoundBlock  = (
	^ notFoundBlock value
)
public versionsUpTo: anotherVersion = (
	^ (self = anotherVersion) 
					ifTrue: [ { self } ]
					ifFalse: [  error  ]  

)
public withAllAncestors = (
	^ Set with: self.
)
) : (
)
public class LeastCommonAncestorsFinder for: aVersion and: anotherVersion = (
|
	v1 = aVersion. 
	v2=  anotherVersion.
|
) (
nonCommonAncestorsFor: elements withCommonAncestors: commonAncestors = (
	| nonCommonAncestors |
	nonCommonAncestors::  Set new .
	elements do: [ :x |  nonCommonAncestors addAll: (x withAllAncestors) ].
	^  nonCommonAncestors reject: [:x  | commonAncestors includes: x ].


)
sameElementsIn: col  = (
	| anyOne |
	anyOne:: col anyOne.
	^ col allSatisfy: [:x | x ==  anyOne ].
)
public value = (
	^ valueForNodes: {v1 . v2}
)
valueForNodes:  elements = (
	|  nonCommonAncestors commonAncestors frontierCommonAncestors res    |
	
	(sameElementsIn: elements) ifTrue: [ ^ {elements anyOne }] .
	
	commonAncestors:: class commonAncestorsFor: elements.
	nonCommonAncestors:: nonCommonAncestorsFor: elements withCommonAncestors: commonAncestors.

	(* frontierCommonAncestors are common ancestors who leak into the nonCommonAncestors group *)
	frontierCommonAncestors::  commonAncestors 
				select: 	 [ :eachCommon |
						 nonCommonAncestors anySatisfy: [:eachNonCommon | 
							eachNonCommon isChildOf: eachCommon    ] ].

	^ frontierCommonAncestors
	
	(*
	(frontierCommonAncestors size = 1) 
		ifTrue: [ ^ frontierCommonAncestors first].	

	(* more than 1 parent *)
	res:: ((commonAncestorsFor: frontierCommonAncestors)  asSortedList: [:x1 :x2 | x1 distanceToRoot >=  x2 distanceToRoot   ]) first .

	^ res *)  

)
) : (
public commonAncestorsFor: elements = (
	^ intersectionOfSets: ( elements collect: [ :x  |  x withAllAncestors ]).
)
public intersectionOfSets: aCollectionOfSets = (
	^ aCollectionOfSets inject:  aCollectionOfSets anyOne into: [ :int :each | int intersection: each ].
)
)
class ObjectVersion withParents: parentsCollection versionedData: dataToVersion  = Version withParents: parentsCollection (
|
	public versionedData ::= dataToVersion.
|
) (
public asChangeRecord = (

	^ ObjectChangeRecord 
		for: (ObjectReference toObjectIdentifiedWith:  principalId)
		withChange: versionedData.
)
) : (
public  withParent: aParent  versionedData: dataToVersion = (
	^ self  withParents: {aParent} versionedData: dataToVersion.
)
)
class ObjectVersionHistory from: aStart upTo: nodes  = (
|
	start ::=  aStart.
	upToNodes = nodes.
	lcas
|
	initializeStart. 
) (
calculateChangesWhenIntersection = (
	| slcas completeParent1Changes changesParent2  combined upToNodesUnionLCAS |
	
	completeParent1Changes:: (class from: start parent1 upTo: upToNodes ) resumedChangeRecord. (*  just pick 1 side *)
	upToNodesUnionLCAS::  lcas union: upToNodes.
	changesParent2:: (class from: start parent2 upTo: upToNodesUnionLCAS ) resumedChangeRecord.
	^ combine: completeParent1Changes and: changesParent2 mergeData: start versionedData. 
)
calculateChangesWhenNoIntersection = (
	| slca completeParent1Changes changesParent2 changesBeyondSLCA combined |
	slca:: (SingleLeastCommonAncestorFinder for:  start parent1 and: start parent2) value.
	completeParent1Changes:: (class from: start parent1 upTo: { slca} ) resumedChangeRecord. (*  just pick 1 side *)
	changesParent2:: (class from: start parent2 upTo: lcas ) resumedChangeRecord.
	
	changesBeyondSLCA:: (class from: slca  upTo: upToNodes) resumedChangeRecord.
	combined:: combine: completeParent1Changes and: changesParent2 mergeData: start versionedData. 
	^ compactRecords: { changesBeyondSLCA . combined }

)
combine: a and: b mergeData: m = (
	| changesDictionary  |

	changesDictionary:: Map new.
	
	a ifNotNil: [
		a changes keysAndValuesDo: [ :k :v | changesDictionary at: k put: v   ].
	].

	b ifNotNil: [
		b changes keysAndValuesDo: [ :k :v | changesDictionary at: k put: v   ].
	].
	m changes keysAndValuesDo: [ :k :v | changesDictionary at: k put: v   ].
	
	^ RegularObjectChange withChanges: changesDictionary.

)
compactRecords: recordsList  = (
	| result filtered|
	filtered:: recordsList reject: [ :x | x isNil ].
	result:: filtered first.
	filtered allButFirst do: [ :each |  result:: result appliedWithChange: each.   ]. 
	^ result
)
historyFrom: aStart  = (
	^ObjectVersionHistory from: aStart upTo: upToNodes.
)
initializeStart = (
	start ifNil: [
		start:: end initialVersion.	 
	]
)
involvedNodes = (
	
	| result pending |
	
	result:: List new.
	pending:: List new.
	
	pending add: start.

	[
		| elem parents |
		elem:: pending first.
		pending removeFirst.
		
		parents:: validParentsFor: elem. 
		parents do: [ :eachParent |
			pending add: 8.
		]
		
	
	] whileTrue: [ pending isEmpty not  ].
	

)
public resumedChangeRecord = (
	|    parents   | 

	(upToNodes includes:  start) 
		ifTrue: [ ^ nil].
	
	parents:: start parentVersions .
	
	(parents size = 0) ifTrue: [
		error.			  
	].
	
	(parents size = 1) ifTrue: [
		| parentRecords |
		parentRecords:: (ObjectVersionHistory from: parents first upTo: upToNodes) resumedChangeRecord. 
		^compactRecords: { parentRecords . start versionedData }.
	].

	
	(parents size = 2) ifTrue: [
		| parent1 parent2  intersection|
		parent1:: parents at: 1.
		parent2:: parents at: 2.
		
		lcas::  (LeastCommonAncestorsFinder 
								for: parent1 
								and: parent2) value.
								
		intersection:: LeastCommonAncestorsFinder intersectionOfSets: { lcas . upToNodes }.
		
		^ intersection isEmpty 
						ifTrue: [ calculateChangesWhenNoIntersection ]
						ifFalse: [ calculateChangesWhenIntersection ].		 				

	].	
	
)
) : (
public completeFor: aVersion = (
	^ self from: aVersion upTo: {aVersion initialVersion}  .
)
)
class ObjectVersionsMerger between: aVersion and: anotherVersion = (
|
	version1 = aVersion.
	version2 = anotherVersion.
|
) (
mergeRecordsBetween: aChangeRecord and: anotherChangeRecord = (
	| changesDictionary commonKeys |

	changesDictionary:: Map new.
	
	commonKeys:: aChangeRecord changes keys intersection: anotherChangeRecord changes keys.
	
	commonKeys do: [ :key  |
		| value1 value2 |
		value1:: aChangeRecord changes at: key.
		value2:: anotherChangeRecord changes at: key.

	 	 (value1 ~= value2) 
				ifTrue:  [  changesDictionary at: key put:  (UnidentifiableObject for:  'UNRESOLVED MERGE CONFLICT') . (* error.  *)].
		].
	
	^ RegularObjectChange withChanges: changesDictionary.
)
public value = (
	| lcas changeRecords1 changeRecords2 mergedData |

	lcas:: (LeastCommonAncestorsFinder for: version1 and: version2) value.
	
	changeRecords1:: (ObjectVersionHistory from: version1 upTo:  lcas) resumedChangeRecord .	
	changeRecords2:: (ObjectVersionHistory from: version2 upTo:  lcas) resumedChangeRecord.

	mergedData:: mergeRecordsBetween: changeRecords1 and: changeRecords2. 
	^ ObjectVersion withParents: { version1 . version2 } versionedData: mergedData.

)
) : (
)
public class SingleLeastCommonAncestorFinder for: aVersion and: anotherVersion = (
|
	v1 = aVersion. 
	v2=  anotherVersion.
|
) (
public value = (
	| lcas res  |
	
	lcas:: (LeastCommonAncestorsFinder for: v1 and: v2) value.
	
	(lcas size = 1) 
		ifTrue: [ ^ lcas first].	

	(* more than 1 parent *)
	res:: ((LeastCommonAncestorsFinder commonAncestorsFor: lcas)  asSortedList: [:x1 :x2 | x1 distanceToRoot >=  x2 distanceToRoot   ]) first .

	^ res 
	
)
) : (
)
class Store name: aName identifiedBy: anId root: aRootObject  = (
|
	public name = aName.
	initialVersion = InitialVersion id: anId.
	versionsById = Map new.
	objectsIdGenerator =  IdGenerator seed: 0 nextIdBlock: [:x | x + 1].
	public anchorVersionId
	rootPrincipalId
|
	registerVersion: initialVersion.
	defineAsAnchor: initialVersion.
	installRoot: aRootObject.
) (
public anchorVersion  = (
	^  versionIdentifiedBy: anchorVersionId.
)
commonAncestorFor: versionsCollection = (
	| versionsAsSet newSet|
	versionsAsSet:: versionsCollection asSet.
	
	(versionsAsSet size =1) 
		ifTrue: [ ^ versionsAsSet anyOne ].
	
	
	newSet:: Set new.
	versionsAsSet do: [:each | newSet addAll: each parentVersions ].
	^ commonAncestorFor: versionsAsSet.
		 
)
computeMergeChangesFrom: targetVersion to: sourceVersion mappingLocalsWith: localToGlobalIds   = (

	|  diff   result |

	(* computes the changes needed to move from sourceVersion to targetVersion*)

	diff:: (AAVersionsDiffer from: targetVersion to: sourceVersion ) value.

	result:: ServerToClientChangeLog 
				mappingIdsWith: localToGlobalIds 
				changeRecords: diff changeRecords  
				newObjects: diff newObjects 
				versionId: targetVersion versionId.  
	
	result rootObjectReference: (clientServerModule ObjectReference toObjectIdentifiedWith: rootPrincipalId).
	^ result.

)
createClientUpdaterFor: aStoreVersion = (
	^ ClientUpdater materializingObjectsWith: [ :aStore |  DefinitionsToObjectVersionsMaterializer objectStore: aStore  ] forContext: aStoreVersion endPoint: self.
)
createEmptyObjectDefinitionFor: anObject enclosingObejctReference: aReference  = (

	| classReference |
	(*^  clientServerModule ObjectDefinition classNamed: (clientServerModule classNameFor: anObject)  enclosingObjectReference: aReference withContents: Map new. *)	

	classReference:: clientServerModule ObjectReferenceByMessageSend receiverReference: aReference selector: (clientServerModule classNameFor: anObject).
	
	^ clientServerModule ObjectDefinition classReference: classReference  withContents: Map new. 	


)
public createNewInitialObjectVersion = (
	 ^ InitialVersion id: generateNextGuid.
)
defineAsAnchor: aVersion = (
	anchorVersionId:: aVersion versionId.
)
public generateNextGuid = (
	^ objectsIdGenerator newId.
)
public id = (
	^ initialVersion principalId.
)
public initialVersionId = (
	^ initialVersion versionId.
)
installRoot: aRootObject = (
	| enclosingObject enclosingObjectReference rootInitialVersion enclosingModuleInitialVersion rootObjectDefinition enclosingModuleObjectDefinition  newStoreVersion |

	enclosingObject:: clientServerModule enclosingObjectForClassOf: aRootObject.

	rootInitialVersion::  createNewInitialObjectVersion.
	enclosingObject 
	ifNil: [
		enclosingObjectReference:: (clientServerModule UnidentifiableObject for: nil).
	]
	ifNotNil: [
		enclosingModuleInitialVersion::  createNewInitialObjectVersion.
		enclosingModuleObjectDefinition::  createEmptyObjectDefinitionFor: enclosingObject enclosingObejctReference: (clientServerModule UnidentifiableObject for: nil).
		enclosingObjectReference:: clientServerModule ObjectReference toObjectIdentifiedWith: enclosingModuleInitialVersion principalId.
	
	].

	rootObjectDefinition::  createEmptyObjectDefinitionFor: aRootObject enclosingObejctReference: enclosingObjectReference.


	newStoreVersion:  newVersionFromAnchor.
	enclosingObject ifNotNil: [ newStoreVersion 	
								addObjectVersionWithParent: enclosingModuleInitialVersion 
						 		versionedData: enclosingModuleObjectDefinition ].
							
	newStoreVersion addObjectVersionWithParent: rootInitialVersion versionedData: rootObjectDefinition.
	defineAsAnchor: newStoreVersion.
	rootPrincipalId:: rootInitialVersion principalId.

)
public isVersion: aVersionId childOf: aParentVersionId   = (
	^ (versionIdentifiedBy: aParentVersionId) hasChildVersionWithId: aVersionId.
)
public isVersion: aParentVersionId parentOf: aVersionId   = (
	^ (versionIdentifiedBy: aParentVersionId) hasChildVersionWithId:  aVersionId.
)
merge: aVersion with: anotherVersion = (
	^ (StoreVersionsMerger between: aVersion and: anotherVersion) value.
)
public newVersionFromAnchor = (
	| newVersion |
	newVersion:: StoreVersion withParent: anchorVersion.
	registerVersion: newVersion.
	
	^ newVersion
)
processNewVersion: aVersion = (

	(anchorVersion  isParentOf: aVersion)  
		ifTrue: [  defineAsAnchor: aVersion.  ]
		ifFalse: [
					| mergedVersion |
				
					mergedVersion:: merge: anchorVersion with: aVersion.
					registerVersion: mergedVersion.
					defineAsAnchor: mergedVersion. 		 ].
)
public pushChanges: aChangeLogFromClient = (
	|  newClientVersion updater localToGlobalIds result  |

	localToGlobalIds:: Map new.
	
	registerNewVersionFrom: aChangeLogFromClient 
					ifNewVersionCreated: [ :newVersion :localToGlobalMap | 
							localToGlobalIds:: localToGlobalMap.
							newClientVersion:: newVersion.
							processNewVersion: newVersion.
		
					] 
					ifNone: [ :v | newClientVersion:: v.].
		
	result:: ServerToClientChangeLog 
				mappingIdsWith: localToGlobalIds 
				changeRecords: {}
				newObjects: {}
				versionId: newClientVersion versionId.  
	
	result rootObjectReference: (clientServerModule ObjectReference toObjectIdentifiedWith: rootPrincipalId).
	^ result.


)
public register: changeLog asChildOfVersionIdentifiedBy: anId  = (
	| parentVersion newVersion |
	parentVersion:: versionIdentifiedBy: anId.
	
	newVersion:: StoreVersion withParent: parentVersion.
	registerVersion: newVersion.
	^ newVersion versionId.
)
registerNewVersionFrom: aChangeLogFromClient 	ifNewVersionCreated:  newVersionCreatedBlock ifNone: noneBlock = (
	| previousClientVersion newStoreVersion updater localToGlobalIds |
	
	previousClientVersion:: versionIdentifiedBy: aChangeLogFromClient versionId.	
	
	aChangeLogFromClient hasNoChanges 
							ifTrue: [ ^  noneBlock value: previousClientVersion ] .

	newStoreVersion:: StoreVersion withParent: previousClientVersion.
	registerVersion: newStoreVersion.
	updater:: createClientUpdaterFor: newStoreVersion.
	localToGlobalIds::  updater updateServerFrom: aChangeLogFromClient.
	newVersionCreatedBlock value: newStoreVersion value: localToGlobalIds.
)
registerVersion: aVersion  = (
	versionsById at: aVersion versionId  put: aVersion.
)
public retrieveCurrentStateChangeLog = (
	 ^ retrieveStateChangeLogAtVersionId: anchorVersionId.	 	
)
public retrieveStateChangeLogAtVersionId: versionId  = (
	 ^ computeMergeChangesFrom: (versionIdentifiedBy: versionId)  
		to:  initialVersion 
		mappingLocalsWith: Map new .	
)
public synchronizeFromChangeLog: aChangeLogFromClient = (
	|  newClientVersion updater localToGlobalIds   |

	localToGlobalIds:: Map new.
	
	registerNewVersionFrom: aChangeLogFromClient 
					ifNewVersionCreated: [ :newVersion :localToGlobalMap | 
							localToGlobalIds:: localToGlobalMap.
							newClientVersion:: newVersion.
							processNewVersion: newVersion.
		
					] 
					ifNone: [ :v | newClientVersion:: v.].
		
	 ^ computeMergeChangesFrom: anchorVersion  
		to:  newClientVersion 
		mappingLocalsWith: localToGlobalIds .



)
public versionIdentifiedBy: aVersionId   = (
	^ versionsById at: aVersionId.
	
)
) : (
)
public class StoreVersion withParents: parents  newVersions: aVersionsCollection deletedIds: deletedIds = Version withParents: parents (
|
	newVersionsById = Map new.
	deletedVersionIds = Set withAll: deletedIds.
|
	initializeVersionsMapFrom: aVersionsCollection. 
) (
public addObjectVersion: aVersion   = (
	newVersionsById at: aVersion principalId put: aVersion.
)
public addObjectVersionWithParent: aParentVersion versionedData: dataToVersion = (
	| newVersion |

	 newVersion:: ObjectVersion withParent: aParentVersion versionedData: dataToVersion.
	addObjectVersion: newVersion.
	^ newVersion
)
initializeVersionsMapFrom: aVersionsCollection = (
	newVersionsById = Map new.
	aVersionsCollection do: [ :each |  addObjectVersion: each ]
	
)
public newVersionsByIdUpTo: aVersion  = (
	| dict |
	
	(aVersion == self) ifTrue: [ ^ Map new ].
	
	dict:: newMapFrom: newVersionsById.
	
	parentVersions do: [ :each | 
		| parentNewVersions |
		parentNewVersions:: each newVersionsByIdUpTo: aVersion.
		parentNewVersions keysAndValuesDo: [ :key :value  |
			| current |
			current:: dict at: key ifAbsentPut: [value].
			
			(value isDescendantOf: current ) ifTrue: [
				dict at: key put: value ].
			
		 ].

	].
	
	^ dict

)
public newVersionsDo: aBlock = (
	^ newVersionsById values do: aBlock.
)
public objectById: anIdentifier ifNotFound: notFoundBlock = (
	^ versionById: anIdentifier ifNotFound: notFoundBlock.		
)
public printOn: aStream = (
	aStream nextPutAll: 'StoreVersion '.
	aStream nextPutAll: fullIdentificationAsString.
)
public versionById: anId = (
	^versionById: anId ifNotFound: [error].
)
public versionById: anId ifFound: foundBlock ifNotFound: notFoundBlock  = (
	| v |  
	v:: versionById: anId ifNotFound: [ ^ notFoundBlock value ].
	foundBlock value: v.
)
public versionById: anId ifNotFound: notFoundBlock  = (

	^ newVersionsById at: anId ifAbsent: [ 

		| versions newestVersion |
		versions:: Set new.
		
		parentVersions do: [ :each |	
			each versionById: anId ifFound: [ :v | versions add: v.  ] ifNotFound: [] .
		].
	
		versions isEmpty ifTrue: [ ^ notFoundBlock value ].
		
		newestVersion:: versions anyOne.
		versions do: [ :each | (each isDescendantOf: newestVersion) 
								ifTrue: [  newestVersion:: each. ]   ].
		
		^newestVersion
		
	].
)
) : (
public withParent: aParent  = (
	^ self withParents: {aParent} newVersions: {} deletedIds: {}.
)
public withParents: parents  = (
	^ self withParents: parents newVersions: {} deletedIds: {}.
)
)
class StoreVersionsMerger between: aVersion and: anotherVersion = (
|
	version1 = aVersion.
	version2  =anotherVersion.
|
) (
mergeObjectVersionBetween: v1 and: v2  = (
	^  (ObjectVersionsMerger between: v1 and: v2) value.
)
public value = (
	| commonAncestor versionsById1 versionsById2 idsToMerge  newObjectVersions |

	commonAncestor:: (SingleLeastCommonAncestorFinder for: version1 and: version2) value.
	
	versionsById1:: version1 newVersionsByIdUpTo:  commonAncestor.	
	versionsById2:: version2 newVersionsByIdUpTo:  commonAncestor.
	
		
	idsToMerge:: versionsById1 keys intersection: versionsById2 keys.
	(* if versions on both branches are the same there is no need for merge *)
	idsToMerge:: idsToMerge select: [ :each |  (versionsById1 at: each) ~= (versionsById2 at: each)  ].
	
	newObjectVersions:: Set new.
	
	idsToMerge do: [ :each |
		| v1 v2 mergedVersion |
		v1:: versionsById1 at: each.
		v2:: versionsById2 at: each.

		mergedVersion:: mergeObjectVersionBetween: v1 and: v2.
		newObjectVersions add: mergedVersion.
		
	].	

	^  StoreVersion withParents: { version1 . version2 }  newVersions:  newObjectVersions deletedIds:  {}.

)
) : (
)
class Version withParents: parents  = (
|
	public versionId = parents anyOne initialVersion generateNextVersionId.
	public parentVersions = List withAll: parents.
	public childVersions = List new.
|
	(parents size > 2) ifTrue: [ error. ].
	parents do: [ :aParent |  aParent registerChild: self] .
) (
public allAncestors = (
	| ancestors |
	ancestors:: Set withAll: parentVersions.
	parentVersions do: [:x | ancestors addAll: x allAncestors. ].
	^ ancestors.
)
assertSingleParent = (
	hasSingleParent ifFalse: [ error].
)
public createChildVersionIn: aUnitOfWork  = (
	error.
)
public distanceToRoot = (
	^ 1 + (parentVersions collect: [ :x | x distanceToRoot]) min.
)
public firstVersion = (
	^initialVersion firstVersion
)
fullIdentificationAsString = (
	principalId asString , '-', versionId asString. 	
)
public hasChildVersionWithId: anId = (
	^ childVersions anySatisfy: [:x | x versionId = anId] 
)
public hasSingleParent  = (
	^ parentVersions size = 1.
)
public initialVersion = (
	^ parentVersions anyOne initialVersion.
)
public isAncestorOf: aVersion  = (
	^aVersion allAncestors includes: self.
)
public isChildOf: aVersion  = (
	^ aVersion isParentOf: self.
)
public isDescendantOf: aVersion  = (
	^ allAncestors includes: aVersion.
)
public  isMergeNode  = (
	^ parentVersions size > 1
)
public isParentOf: aVersion  = (
	^ hasChildVersionWithId: aVersion versionId.
)
public parent1 = (
	^parentVersions at: 1.
)
public parent2 = (
	^parentVersions at: 2.
)
public principalId = (
	^ initialVersion principalId.
)
public printOn: aStream = (
	aStream nextPutAll: 'Version '.
	aStream nextPutAll: versionId asString.
)
public registerChild: aVersion = (
	childVersions add: aVersion.
)
public singleParentVersion = (
	assertSingleParent.
	^ parentVersions  anyOne.
)
public singleParentVersionId  = (
	^ singleParentVersion versionId 
)
public uniqueId = (
	^ CompoundVersionId principal:  principalId versionId: versionId.
)
public versionType = (
	^ initialVersion versionType.
)
public versionsUpTo: anotherVersion = (
	(* includes anotherVersion  *)
	assertSingleParent.

	^ (self = anotherVersion) 
					ifTrue: [ { self } ]
					ifFalse: [   (singleParentVersion versionsUpTo: anotherVersion) , { self }  ]  

)
public withAllAncestors = (
	| ancestors |
	ancestors:: Set withAll: allAncestors.
	ancestors add: self.
	^ ancestors.
)
) : (
public withParent: aParent = (
	^ self withParents: { aParent }
)
)
public class VersionsServer = (
|

	storesById = Map new.
	idGenerator = IdGenerator seed: 0 nextIdBlock: [:x | x + 1]. 
|
) (
public containsStoreNamed: aName  = (
	^ storesById values anySatisfy: [:each | each name = aName].
)
public createStoreNamed: aName  root: aRootObject = (
	| newStore |
	newStore:: Store name: aName identifiedBy: idGenerator newId root: aRootObject. 
	storesById at: newStore id put: newStore. 
	^ newStore.
)
public storeIdentifiedBy: anId  = (
	^ storesById at: anId.
)
public storesCount  = (
	^ storesById size.
)
) : (
)
ClientUpdater = (
	^ clientModule ClientUpdater
)
ObjectChangeRecord = (
	^ clientServerModule ObjectChangeRecord. 
)
ObjectReference = (
	^ clientServerModule ObjectReference. 
)
ObjectsMaterializer = (
	^ clientModule ObjectsMaterializer
)
RegularObjectChange = (
	^ clientServerModule RegularObjectChange. 
)
ServerToClientChangeLog = (
	^ clientServerModule ServerToClientChangeLog
)
UnidentifiableObject = (
	^ clientServerModule UnidentifiableObject. 
)
newMapFrom: aMap = (
	^ clientServerModule newMapFrom: aMap.

)
) : (
)
