Newspeak3
'OrthogonalSynchronization'
class ClientSynchronizationTesting usingPlatform: p model: clientSync minitest: m  = (
|
	StoreClient = clientSync StoreClient.
	ChangeTrackingContext = clientSync ChangeTrackingContext.
	ClientUpdater = clientSync ClientUpdater.
	InMemoryStoreBroker  = clientSync InMemoryStoreBroker.
	
	List = p collections List.
	Map = p collections Map.
	ObjectMirror = p mirrors ObjectMirror.
	TestContext = m TestContext.

	public toDoListModel 
	public clientServerModule
	public versioningModule
	public manifest	
		
|
) (
public class ClientSynchronizationTests  = TestContext (
|

	server
	
	initialObjectsIdByName
	initialObjectsByName
	
	storeClient
	
|
	
	server: createServer. 
	storeClient:: StoreClient  server: server.
	


) (
public   AAAtestAAATestGilad = (
	| task1Id client1 client2 task1OnClient1 task1OnClient2 task1OnServer  storeVersion     |  

	installContextFromServer.
	task1Id:: (objectIdForName: 'task1').
	
	client1:: server newClient.
	task1OnClient1:: client1 objectById: task1Id  . 
	task1OnClient1 text: 'text v1'.
	client1 synchronize.
	
	client2:: server newClient.
	task1OnClient2:: client2 objectById: task1Id .
	task1OnClient2 text: 'text v2'.
	client2 synchronize.

 
	storeVersion:: server newClient. 
(*	storeVersion:: server atVersion: client2 version.  *)
	task1OnServer:: storeVersion objectById: task1Id.


	synchronize.
	assert: task1OnServer text equals:  'text v2'.


)
public   AAAtestClientUpdateAAAA= (
	| task1 toDoListModelCli        |  

	installContextFromServer.

	task1:: clientObjectNamed: 'task1' .

	 withNewClientDo: [ :newClient |
		| task1OnNewSession     |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1) .
		task1OnNewSession text: 'text v2'.
	].

	 withNewClientDo: [ :newClient |
		| task1OnNewSession     |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1) .
		task1OnNewSession text: 'text v3'.
	].

	task1 text2: 'text2 v2'. 

	synchronize.
	assert: task1 text equals:  'text v3'  .
	assert: task1 text2 equals:  'text2 v2'.

)
aa = (

	|  newTask anotherNewTask values   ids changes  internalTasksArray   | 


	anotherNewTask::  ToDoTask describedBy: 'another new task' dependsOn: task2.
	newTask::  ToDoTask describedBy: 'my new task' dependsOn: anotherNewTask.

	
	

	internalTasksArray::  contentForSlot: #contents in: tasks.

	
	ids::  Map new.
	ids at: task1 put: 1.
	ids at: task2 put: 2	.
	ids at: task3 put: 3.
	ids at: root put: 4.
	ids at: tasks put: 5.
	ids at: internalTasksArray put: 6.

	
	
	cto installNewRoot: root identifiedBy: ids.

(*	changes:: cto detectChanges.	*)
	(* no changes *)

	tasks at: 1 put: task2.
	tasks at: 2 put: anotherNewTask.

(*
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
	tasks add: task1.
*)	
	internalTasksArray:: nil. 

	changes:: cto detectChanges.	

(*	assert: exp equals:   *)
	


	 
)
clientObjectNamed: aName  = (
	^ storeClient objectById: (objectIdForName: aName).
	
)
contentForSlot: aSlotName in: anObject  = (
	| mirror |
	mirror:: ObjectMirror  reflecting: anObject.
	^  (mirror getSlot: aSlotName) reflectee.
)
createInitialObjectsForTestsByName = (
	^ createInitialObjectsForTestsByNameFromRoot:  toDoListModel RootModel new.
)
createInitialObjectsForTestsByNameFromRoot: root = (

	| map internalTasksArray 	relatedTasks task1 	task2 	task3   	tasks enclosing  | 

	enclosing::  clientServerModule enclosingObjectForClassOf: root.

	task3::  enclosing ToDoTask describedBy: 'my task 3' dependsOn: nil.
	task2::   enclosing ToDoTask describedBy: 'my task 2' dependsOn: task3.
	task1::  enclosing ToDoTask describedBy: 'my task 1' dependsOn: task2.

	relatedTasks:: Array with: 1 with: task1.
	task1 relatedTasks: relatedTasks.
	
	tasks:: List new.
	tasks add: task1.
	tasks add: task2.
	tasks add: task3.


	root task: task1.
	(*root elements: tasks. *)
	
	(* internalTasksArray:: contentForSlot: #contents in: tasks. *)
	

	map:: Map new.
	map at: 'task1' put:  task1.
	map at: 'task2' put:  task2.	
	map at: 'task3' put:  task3.
	map at: 'relatedTasksForTask1' put:  relatedTasks.
(*	map at: 'tasks' put:  tasks. *)
(*	map at: 'internalTasksArray' put:  internalTasksArray. *)
	map at: 'root' put:  root.
	map at: 'toDoListModel' put: enclosing. 
	
	 ^ map.


)
createServer = (
	| store versionsServer |
	versionsServer:: versioningModule VersionsServer new.
	store:: versionsServer createStoreNamed: 'myStore' root: RootModel new .

	^  InMemoryStoreBroker store: store
)
createTaskChainOfLength: n usingClass: taskClass  = (
	| current |
	current:: nil.
	(1 to: n) do: [ :x |
			current:: taskClass describedBy: ('new task chain ', x)  dependsOn: current.
	].
	^ current
)
cto  = (

	^storeClient cto.
)
installContextFromLocal   = (
	| map nextId | 
	initialObjectsByName:: createInitialObjectsForTestsByName. 
	map:: Map new.

	nextId:: 1.	
	initialObjectsByName keysAndValuesDo: [ :name :obj |  
													map at: obj put: nextId. 
													nextId:: nextId +1.  ]. 

	storeClient cto  installNewObjectsFromIObjectToIdsMap: map.
	 
)
installContextFromServer   = (
	installInitialVersionInServer.	
	installContextFromServerInto: storeClient. 

)
installContextFromServerInto: aStoreClient   = (
	^ aStoreClient synchronize.
)
installInitialVersionInServer = (
	| client objectsByName |
	client:: StoreClient  server: server.
	client synchronize.
	objectsByName:: createInitialObjectsForTestsByNameFromRoot: client root.
	client synchronize.
	initialObjectsIdByName::  Map new.  
	objectsByName keysAndValuesDo: [ :name :object |   initialObjectsIdByName at: name put: (client idForObject:  object) ].
)
mergeConflictToken = (
	^'UNRESOLVED MERGE CONFLICT' 
)
objectIdForName: aName  = (
	^  initialObjectsIdByName at: aName
)
objectNamed: aName  = (
	^ initialObjectsByName at: aName.
)
snapshotAtAnchorVersion = (
	^ server newClient .	
)
synchronize = (
	^ storeClient synchronize.
)
public   testChangesAreDetectedWhenModifyingArray = (
	|   task1 task2 changeLog  changeRecord| 

	installContextFromLocal.

	task1:: objectNamed:  'task1' .
	task2:: objectNamed:  'task2' .
	
	task1 relatedTasks at: 1 put: 2.
	task1 relatedTasks at: 2 put: task2.


	changeLog:: cto detectChanges changeLog.

	assert: changeLog changeRecords size equals: 1.

	changeRecord:: changeLog changeRecords first.
	assert:  (changeRecord  refersTo: task1 relatedTasks in: cto).
	
	assert:  changeRecord changes  size equals: 2.
	assert:  ((changeRecord changes at: 1) refersTo: 2).
	assert:  ((changeRecord changes at: 2) refersTo: task2 inContext: cto).
	
	
		
	assert:  changeLog  hasNoNewObjectsDefinitions.
	 
)
public   testChangesAreDetectedWhenModifyingBasicValueForSlot = (
	|   task1 changeLog newTextForTask changeRecord| 

	installContextFromLocal.

	newTextForTask::  'modified task1' .
	task1:: objectNamed:  'task1' .
	 task1 text: newTextForTask.

	changeLog:: cto detectChanges changeLog.

	assert: changeLog changeRecords size equals: 1.

	changeRecord:: changeLog changeRecords first.
	assert:  (changeRecord  refersTo: task1 in: cto).
	
	assert:  changeRecord changes  size equals: 1.
	assert:  (changeRecord changes includesKey: #text).
	assert:  ((changeRecord changes at: #text) refersTo: newTextForTask inContext: cto).

	assert:  changeLog  hasNoNewObjectsDefinitions.
	 
)
public   testClientGetsUpdatedCorrectlyAfterMultipleVersionChanges = (
	| task2  task3     newTextForTask2 newTextForTask3  |  


	installContextFromServer.
	
	task2:: clientObjectNamed: 'task2' .	
	task3:: clientObjectNamed: 'task3' .	


	newTextForTask2:: 'changed task2'.		
	newTextForTask3:: 'changed task3'.		

	withNewClientDo: [ :newClient |
		| task2OnNewSession |
		task2OnNewSession:: newClient objectById: (storeClient idForObject:  task2)  .
		task2OnNewSession text: newTextForTask2 .
	].


	withNewClientDo: [ :newClient |
		| task3OnNewSession |
		task3OnNewSession:: newClient objectById: (storeClient idForObject:  task3)  .
		task3OnNewSession text: newTextForTask3 .
	].


	synchronize.

	assert: storeClient currentVersion equals: server  currentAnchorId.
	assert: task2 text equals: 	newTextForTask2.
	assert: task3 text equals: 	newTextForTask3.
				
		
	 
)
public   testClientUpdateSimpleMerge = (
	| task1 toDoListModelCli   newTask newTaskOnNewSession anotherClient   |  


	installContextFromServer.

	task1:: clientObjectNamed: 'task1' .
	task1 text: 'text client 1' .
		

	anotherClient::  withNewClientDo: [ :newClient |
		| task1OnNewSession  toDoListModelOnNewSession   |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1) .
		task1OnNewSession text2: 'text 2 client 2' .
	].


	synchronize.

	assert: task1 text equals:  'text client 1'  .
	assert: task1 text2 equals:  'text 2 client 2'  .
	 
)
public   testClientUpdateWithNewObjectFromServer = (
	| task1 toDoListModelCli   newTask newTaskOnNewSession anotherClient   |  


	installContextFromServer.

	task1:: clientObjectNamed: 'task1' .
	toDoListModelCli::  clientObjectNamed: 'toDoListModel' .


	anotherClient::  withNewClientDo: [ :newClient |
		| task1OnNewSession  toDoListModelOnNewSession   |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1) .
		toDoListModelOnNewSession:: newClient objectById: (storeClient idForObject:  toDoListModelCli) .
		
		newTaskOnNewSession:: toDoListModelOnNewSession ToDoTask describedBy: 'new task' dependsOn: nil .
		task1OnNewSession dependsOn: newTaskOnNewSession. 
		task1OnNewSession relatedTasks at: 1 put: 'new item' . 
		
	].


	synchronize.


	(* maybe replace the multiple assertions with something like this or even create a generic version for any pair of objects *)
	(* assertLocalTask: newTask correspondsTo: newTaskOnSession on: anotherContext. *)

	newTask:: task1 dependsOn.		
	assert: (storeClient isTracked: newTask) description: 'New task is not tracked on client' .
	assert: (storeClient idForObject: newTask) equals:  (anotherClient idForObject: newTaskOnNewSession) .
	assert: (task1 relatedTasks at: 1) equals:  'new item'  .
		
	assert: newTask text equals: newTaskOnNewSession text .
	 
)
public   testClientUpdateWithNewObjectFromServerAndMerge = (
	| task1 toDoListModelCli   newTask newTaskOnNewSession anotherClient   |  

	installContextFromServer.

	task1:: clientObjectNamed: 'task1' .
	task1 text: 'new text' .

	toDoListModelCli::  clientObjectNamed: 'toDoListModel' .


	anotherClient::  withNewClientDo: [ :newClient |
		| task1OnNewSession  toDoListModelOnNewSession   |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1) .
		toDoListModelOnNewSession:: newClient objectById: (storeClient idForObject:  toDoListModelCli) .
		
		newTaskOnNewSession:: toDoListModelOnNewSession ToDoTask describedBy: 'new task' dependsOn: nil .
		task1OnNewSession dependsOn: newTaskOnNewSession. 
		task1OnNewSession relatedTasks at: 1 put: 'new item' . 
		
	].


	synchronize.


	(* maybe replace the multiple assertions with something like this or even create a generic version for any pair of objects *)
	(* assertLocalTask: newTask correspondsTo: newTaskOnSession on: anotherContext. *)

	newTask:: task1 dependsOn.		
	assert: (storeClient isTracked: newTask) description: 'New task is not tracked on client' .
	assert: (storeClient idForObject: newTask) equals:  (anotherClient idForObject: newTaskOnNewSession) .
	assert: (task1 relatedTasks at: 1) equals:  'new item'  .
	assert: task1 text equals:  'new text'  .
		
	assert: newTask text equals: newTaskOnNewSession text .
	 
)
public   testMergeConflictOnSlot = (
	| task1  baseVersion     | 
	installContextFromServer.

	task1:: clientObjectNamed: 'task1' .

	baseVersion:: storeClient currentVersion.

	withNewClientFromVersion: baseVersion do: [ :newClient |
		| task1OnNewSession   |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1) .
		task1OnNewSession text: 'text v1'.
	].

	withNewClientFromVersion: baseVersion do: [ :newClient |
		| task1OnNewSession   |
		task1OnNewSession:: newClient objectById: (storeClient idForObject:  task1) .
		task1OnNewSession text: 'text v2'.
	].
 
	synchronize.
	assert: task1 text equals:  mergeConflictToken.
	
	
)
public   testMergePointsShouldOnlyStoreDecisions= (
	 

	| task1Id client1 client2 task1OnClient1 task1OnClient2 task1OnServer  storeVersion snapshot     |  

	installContextFromServer.
	task1Id:: (objectIdForName: 'task1').


	client2:: server newClient.
	task1OnClient2:: client2 objectById: task1Id .

	client1:: server newClient.
	task1OnClient1:: client1 objectById: task1Id  . 

	(* B *)	
	task1OnClient1 text2: 'C'.
	client1 synchronize.

	(* C *) 	
	task1OnClient2 text: 'Y'.
	client2 synchronize.

	(* D *)
	task1OnClient2 text2: 'D'.
	client2 synchronize.

	snapshot:: snapshotAtAnchorVersion.	
	task1OnServer:: snapshot objectById: task1Id  . 
	
	assert: task1OnServer text equals:  'Y'.
	assert: task1OnServer text2 equals:  'D'.

)
public   testMergeScenarioEx1= (
	 
	| task1Id client1 client2 client3 client4 task1OnServer task1OnClient1 task1OnClient2 task1OnClient3 task1OnClient4  snapshot  |  

	installContextFromServer.
	task1Id:: (objectIdForName: 'task1').

	
	(* A *) 
	client2:: server newClient.
	task1OnClient2:: client2 objectById: task1Id  . 
	task1OnClient2 text2: 'A'.
	client2 synchronize.	

	(* X *)	
	task1OnClient2:: client2 objectById: task1Id  . 
	task1OnClient2 text2: 'X'.
	client2 synchronize.	

	(* B *)	
	task1OnClient2 text2: 'B'.
	client2 synchronize.	

	client1:: server newClient.
	task1OnClient1:: client1 objectById: task1Id  . 


	client3:: server newClient.
	task1OnClient3:: client3 objectById: task1Id  . 
	
	(* F *)	
	task1OnClient2 text2: 'F'.
	client2 synchronize.	
	
	client4:: server newClient.
	task1OnClient4:: client4 objectById: task1Id  . 

	(* E *)	
	task1OnClient1 text: 'E'.
	client1 synchronize.	
	(* H is created by merging F and E *)


	(* D *)	
	task1OnClient3 text: 'Y'.
	client3 synchronize.	
	(* I is created by merging H and D *)


	snapshot:: snapshotAtAnchorVersion.	
	task1OnServer:: snapshot objectById: task1Id  . 
	assert: task1OnServer text equals:  mergeConflictToken.

	(* G *)	
	task1OnClient4 text2: 'G'.
	client4 synchronize.	
	(* ? is created by merging G and I *)

	
	
	snapshot:: snapshotAtAnchorVersion.	
	task1OnServer:: snapshot objectById: task1Id  . 
	assert: task1OnServer text2 equals:  'G'.


)
public   testMergeScenarioEx4= (
	 
	| task1Id client1 client2 task1OnClient1 task1OnClient2 task1OnServer  snapshot  |  

	installContextFromServer.
	task1Id:: (objectIdForName: 'task1').

	client1:: server newClient.
	
	(* A *) 
	task1OnClient1:: client1 objectById: task1Id  . 
	task1OnClient1 text2: 'A'.
	client1 synchronize.	

	(* X *)	
	client2:: server newClient.
	task1OnClient2:: client2 objectById: task1Id  . 
	task1OnClient2 text2: 'X'.
	client2 synchronize.	

	(* B *)	
	task1OnClient2 text2: 'B'.
	client2 synchronize.	

	(* Y *)	
	task1OnClient1 text: 'Y'.
	client1 synchronize.	
	(* F is created by merging Y and B *)

	(* J *)	
	task1OnClient1 text: 'J'.
	client1 synchronize.	


	(* D *)	
	task1OnClient2 text2: 'D'.
	client2 synchronize.	
	(* Z is created by merging J and D *)
	
	snapshot:: snapshotAtAnchorVersion.	
	task1OnServer:: snapshot objectById: task1Id  . 
	
	assert: task1OnServer text equals:  'J'.
	assert: task1OnServer text2 equals:  'D'.

)
public   testNewObjectsAreDetectedOnClient = (
	|   task1 changeLog newTask changeRecord newReference newTaskDefinition| 

	installContextFromLocal.

	task1:: objectNamed: 'task1' .

	newTask:: ToDoTask describedBy: 'new task' dependsOn: nil .
	task1 dependsOn: newTask.

	changeLog:: cto detectChanges changeLog.

	assert: changeLog changeRecords size equals: 1.

	changeRecord:: changeLog changeRecords first.
	assert:  (changeRecord  refersTo: task1 in: cto).
	
	assert:  changeRecord changes  size equals: 1.
	assert:  (changeRecord changes includesKey: #dependsOn).

	newReference:: changeRecord changes at: #dependsOn.

	assert:  newReference isKindOfNewObjectReference.
	
	assert:  changeLog newObjectsDefinitions size equals: 1.
	newTaskDefinition:: changeLog newObjectsDefinitions first.
	
	assert:  newReference identifier  equals: newTaskDefinition id.
	
	assert: (newTaskDefinition definition slotNamed: #text hasValue: newTask text).
	assert: (newTaskDefinition definition slotNamed: #dependsOn hasValue: newTask dependsOn).
	 
)
public   testNoChangesAreDetectedWhenNothingHasChanged = (
	|   changeLog  | 
	installContextFromLocal.
	changeLog:: cto detectChanges changeLog.	
	assert:  changeLog hasNoChanges.
	 
)
public   testPerformanceChangeDetection = (
	| task3 toDoListModelCli	|
	
	installContextFromLocal.
	
	task3:: objectNamed: 'task3' .
	task3 dependsOn:  ( createTaskChainOfLength: 4 usingClass:  ToDoTask) .

	cto detectChanges.
	
	 
)
public   testPerformanceTaskChain = (
	| task3 toDoListModelCli	|
	
	installContextFromServer.
	
	task3:: clientObjectNamed: 'task3' .
	toDoListModelCli::  clientObjectNamed: 'toDoListModel' .

	withNewClientDo: [ :newClient |
		| task3OnNewSession toDoListModelOnNewSession newTask |
		task3OnNewSession:: newClient objectById: (storeClient idForObject: task3 )  .
		toDoListModelOnNewSession:: newClient objectById: (storeClient idForObject:  toDoListModelCli) .
		newTask::   createTaskChainOfLength: 4 usingClass: toDoListModelOnNewSession ToDoTask .
		
	
		task3OnNewSession dependsOn: newTask.
	
	
	].

	synchronize.


(*
	assert: storeClient currentVersion equals: server  currentAnchorId.
	assert: task2 text equals: 	newTextForTask2.
	assert: task3 text equals: 	newTextForTask3.
		*)
				
	 
)
public   testThereAreNoPendingChangesAfterSynchronization = (
	| task1 |  

	installContextFromServer.

	task1:: clientObjectNamed: 'task1' .
	task1 text: ' new desc' .
	synchronize.

	assert: (storeClient hasPendingChanges not) description: 'There are pending changes after sync' .

)
public testTransientSlotsAreResetedAfterSync = (
	| task1 old  |  

	installContextFromServer.

	task1:: clientObjectNamed: 'task1' .
	old:: task1 textTransient. (* this send is for caching the current value *)

	task1 text: 'new desc' .

	assert: task1 textTransient equals: old .
	synchronize.
	assert: task1 textTransient equals: task1 text .
	 
)
withNewClientDo: aBlock = (
	| newClient |
	newClient:: StoreClient server: server.  
	installContextFromServerInto: newClient .
	aBlock value: newClient.
	newClient synchronize.
	^ newClient
	
)
withNewClientFromVersion: aVersionNumber do: aBlock = (
	| newClient |
	
	newClient:: StoreClient server: server.  
	newClient checkoutVersion: aVersionNumber.
	aBlock value: newClient.
	newClient synchronize.
	^ newClient
	
)
) : (
TEST_CONTEXT = ()
)
public class VersionsServerTests = TestContext (
|
	versionsServer = versioningModule VersionsServer new.
	store  = versionsServer createStoreNamed: storeName root: RootModel new.
	
|
) (
createFooObjectChangeLog = (
	| changeLog fooObjectDefinition fooObjectDefinitionWithId valuesBySlot |
	
	valuesBySlot:: Map new. 
	valuesBySlot at: 'slot1'  put: (ServerToClientChangeLog UnidentifiableObject value: 1). 
	
	fooObjectDefinition:: ServerToClientChangeLog ObjectDefinition classNamed: 'Foo'  enclosingObjectReference: nil withContents: valuesBySlot.
	
	fooObjectDefinitionWithId:: ServerToClientChangeLog ObjectDefinitionWithIdentification id: 1 definition: fooObjectDefinition.
	
	^ ServerToClientChangeLog withChanges: {}  withNewObjects: { fooObjectDefinitionWithId }.
)
dummyChangeLog = (
	^ nil
)
storeName  = (
	^ ' MyStore' 
)
public testLCAIsFoundCorrectlyInComplexDAG   = (
	| version1  version11  version111 version12 version123 version12_11Merge version122 version12Merge versionMergeA  lcas |

	version1:: StoreVersion withParents: { InitialVersion id: 1 }.	
	version11:: StoreVersion withParent: version1.
	version111:: StoreVersion withParent: version11.

	version12:: StoreVersion withParent: version1.
	version12_11Merge:: StoreVersion withParents: { version12 . version11 }.
	version122:: StoreVersion withParent: version12.
	version12Merge:: StoreVersion withParents: { version12_11Merge . version122}.

	versionMergeA:: StoreVersion withParents: { version12_11Merge . version111}.
	lcas:: (LeastCommonAncestorsFinder for: versionMergeA and: version12Merge) value. 
	assert: lcas size equals: 3. 
	assert: (lcas includes:  version12).
	assert: (lcas includes:  version11).
	assert: (lcas includes:  version12_11Merge).

)
public testLCAIsFoundCorrectlyInSimpleDAG   = (
	| version1  version11 version12 version121 version122 version12Merge lcas |
 
	version1:: StoreVersion withParents: { InitialVersion id: 1 }.	
	version11:: StoreVersion withParent: version1.
	version12:: StoreVersion withParent: version1.
	version121:: StoreVersion withParent: version12.
	version122:: StoreVersion withParent: version12.
	
	version12Merge:: StoreVersion withParents: { version121 . version122}.
		
	 lcas:: (LeastCommonAncestorsFinder for: version11 and: version12Merge) value.
	assert: lcas size equals: 1. 
	assert: lcas anyOne equals: version1.
	
	 	
)
public testLCAIsFoundCorrectlyInSimpleTree   = (
	| version1  version11 version12 lcas |

	version1:: StoreVersion withParents: { InitialVersion id: 1 }.	
	version11:: StoreVersion withParent: version1.
	version12:: StoreVersion withParent: version1.
		
	 lcas:: (LeastCommonAncestorsFinder for: version11 and: version12) value. 
	assert: lcas size equals: 1. 

	assert: lcas anyOne equals: version1.
	
	 	
)
public testLCAIsFoundCorrectlyInTree   = (
	| version1  version11 version12 version121 lcas |

	version1:: StoreVersion withParents: { InitialVersion id: 1 }.	
	version11:: StoreVersion withParent: version1.
	version12:: StoreVersion withParent: version1.
	version121:: StoreVersion withParent: version12.
		
	 lcas:: (LeastCommonAncestorsFinder for: version11 and: version121) value. 

	assert: lcas size equals: 1. 
	assert: lcas anyOne equals: version1.
	
	 	
)
public testNewStoreVersionIsCreatedCorrectly   = (
	| newVersionId |
	newVersionId:: store register: dummyChangeLog asChildOfVersionIdentifiedBy: store initialVersionId.  
	assert: (store isVersion: newVersionId childOf: store initialVersionId).
	assert: (store isVersion: store initialVersionId parentOf:  newVersionId ).  
	 	
)
public testStoreIsCreatedCorrectly  = (
	| newServer newStore |
	newServer:: versioningModule VersionsServer new.
	newStore:: newServer createStoreNamed: storeName root: RootModel new.
	assert: newStore name equals: storeName.
	assert: (newServer containsStoreNamed: storeName).
	assert: newServer storesCount equals: 1.
)
) : (
TEST_CONTEXT = (
)
)
ClientToServerChangeLog  = (
	^clientServerModule ClientToServerChangeLog.
)
InitialVersion = (

	^ versioningModule InitialVersion
)
LeastCommonAncestorsFinder = (
	^ versioningModule LeastCommonAncestorsFinder
)
LowerCommonAncestorsFinder = (
	^ versioningModule LowerCommonAncestorsFinder
)
RootModel = (
	^ toDoListModel RootModel.
)
ServerToClientChangeLog  = (
	^clientServerModule ServerToClientChangeLog.
)
StoreVersion = (

	^ versioningModule StoreVersion
)
ToDoTask = (
	^ toDoListModel ToDoTask.
)
) : (
)
