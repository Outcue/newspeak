Newspeak3
'HopscotchIDE'
class SimpleBrowsing usingPlatform: p ide: webIde = (
(* An IDE for Newspeak on the web.
    Copyright 2016-2017 Google Inc.
    Copyright 2018-2020 Gilad Bracha.
*)
|	(* imports *)
	StringBuilder = p kernel StringBuilder.
	Subject = p hopscotch core Subject.
	Presenter = p hopscotch core Presenter.	
	TextEditorFragment = p hopscotch fragments TextEditorFragment.
	Color = p graphics Color.
	Gradient = p hopscotch Gradient.
	List = p collections List.
	Map = p collections Map.
	ClassMirror = p mirrors ClassMirror.
	ObjectMirror = p mirrors ObjectMirror.
	ClassDeclarationBuilder = p mirrors ClassDeclarationBuilder.
	JSObject = p js global at: 'Object'.
	JSMath = p js global at: 'Math'.
		(* module variables *)
	cachedPlatform = p.
	ide = webIde.
	detailAreaRatio = 3 asFloat.
	captionColor = Color h: 240 s: 0.05 asFloat v: 0.9 asFloat.
	cssConverter = cssConversionTable.
|
) (
public class AssortedMethodsPresenter onSubject: s = DefinitionListPresenter onSubject: s (
(* The subject is a collection of MethodSubjects that can come from diverse sources (in the sense that they do not have to belong to the same class). The presenter displays them as a column of expandable method presenters and takes care of reasonably handling the various creation and deletion requests coming from them.  I group my methods by their containing package.

Slots
	title	<String>	The title to use for the presenter
	methodPresenters <List[ExpandableMethodPresenter]> Because the method presenters are grouped by package, if we need to expand or collapse those presenters, we only want to expand or collapse the method presenters.  The group heading is not expandable (or collapsable). *)
|
	public title ::= 'Assorted Methods'.
	methodPresenters ::= List new.
|) (
contentPresenters = (
      #BOGUS.
	^subject methodSubjects collect: [:each | each presenter]
)
) : (
)
class BasicView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	^column:
		(subject slots collect:
			[:slot <SlotSubject> | slot presenter])
)
public isKindOfBasicView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfBasicView
)
public title = (
	^'Basic'
)
) : (
)
public class BitOfWisdom text: s <String> actionLabel: l <String> actionBlock: b <[]> image: i = (|
	public text <String> = s.
	public image = i.
	public actionLabel <String> = l.
	public actionBlock <[]> = b.
|) (
) : (
public text: s <String> ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: nil
)
public text: s <String> actionLabel: l <String> actionBlock: b <[]> ^ <BitOfWisdom> = (
	^self
		text: s
		actionLabel: l
		actionBlock: b
		image: nil
)
public text: s image: i ^ <BitOfWisdom> = (
	^text: s actionLabel: nil actionBlock: nil image: i
)
)
class ClassActionsPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
definition = (
	^row: {testActions. (*benchmarkActions. applicationActions*) }
)
public isKindOfClassActionsPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassActionsPresenter
)
testActions = (
	subject isTestConfiguration ifFalse: [^nothing].
	^link: '[run tests]' action: [enterSubject:: subject testingSubject].
)
) : (
)
class ClassCommentPresenter onSubject: s <ClassSubject> = ProgrammingPresenter onSubject: s (
|
  editor
  isEditing ::= false.
  showPartialIfLong ::= true.
  showingPartial
|
) (
= anotherPresenter = (
	^self == anotherPresenter
)
definition = (
	^holder:
		[isEditing
			ifTrue: [editorDefinition]
			ifFalse: [viewerDefinition]]
)
definitionText = (
	(* In this class, only used by the editor side of the presenter to get the text to show in the editor. *)

	^fullCommentText
)
editorDefinition = (
	editor:: TextEditorFragment new.
	editor
		text: definitionText;
		cancelResponse: [respondToCancel];
		acceptResponse: [respondToAccept];
		enterEditState.
	^editor
)
enterEditState = (
	isEditing:: true.
	refresh
)
fullCommentText = (
	^subject classCommentText asString
)
hash = (
	^self identityHash
)
public isKindOfClassCommentPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassCommentPresenter
)
public leaveEditState = (
	isEditing:: false.
	refresh
)
maybePartialCommentText ^<String> = (
  ^fullCommentText size > 500 ifTrue: [
	showingPartial:: true.
	subject classCommentSummary
	] ifFalse: [
	showingPartial:: false.
	fullCommentText
	]
)
presentationDefinition = (
	| textToDisplay |
	textToDisplay:: retrieveComment.
	textToDisplay isEmpty ifTrue:
		[textToDisplay:: '(no comment)'].
	^column:
		{textDisplay: textToDisplay.
		showingPartial
			ifTrue: [(link: 'show full comment' action: [showFullComment])]
			ifFalse: [(link: 'hide full comment' action: [showLessComment])].
		}
)
respondToAccept = (
	subject classCommentText: editor textBeingAccepted. leaveEditState.
)
respondToCancel = (
	leaveEditState
)
respondToEdit = (
	enterEditState
)
retrieveComment ^<String> = (
	(* Get the text to display--either the whole thing or the first paragraph, depending on the text and the settings--and set the showingPartial slot accordingly. *)

	^showPartialIfLong
		ifTrue:
			[maybePartialCommentText]
		ifFalse:
			[showingPartial:: false.
			fullCommentText]
)
showFullComment = (
	showPartialIfLong:: false.
	refresh
)
showLessComment = (
	showPartialIfLong:: true.
	refresh
)
viewerDefinition = (
^
	row: {
		elastic:
			presentationDefinition.
		smallBlank.
		(* linkImage:  editImage action: [respondToEdit]*)
		}
)
) : (
)
class ClassEntryPresenter onSubject: s <ClassSubject> = EntryPresenter onSubject: s () (
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier).
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
collapsedDefinition = (
	^row1: {
		image: ide images classIcon.
		smallBlank.
		accessIndicator.
		smallBlank.
		link: subject name action: [enterSubject:: ClassSubject onModel: subject classMirror].
	} row2: {
		(row: {deferred: [(label: subject classCommentSummary)
			smallFont;
			color: secondaryTextColor]})
				compressibility: 1.
		filler
			compressibility: 0.

		ClassActionsPresenter onSubject: subject.
		mediumBlank.
		entryActionsMenu.
	}
)
entryActionsMenu = (
	^nothing
)
expandedDefinition = (
	^subject presenter
)
public tag ^ <String> = (
  ^subject name
)
) : (
)
class ClassFactoryPresenter onSubject: s <ClassFactorySubject> = MethodPresenter onSubject: s (
(* WIP. Present the factory method, colorized *)
 | toggle <ToggleComposer> |
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror asBuilder. |
		updateGUI: [
			b header source: ed textBeingAccepted.
			b install.
			colorizeHeaderSource: (crToLf: ed textBeingAccepted)  withEditor: ed.
			ed leaveEditState.
		].
		ed editor focus.
	]
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed enterEditState.
	 ]
)
collapsedDefinition ^ <Fragment> = (
  ^column: {
      headerDefinition.
      label: subject classCommentSummary.
      mediumBlank.
	slotList.
	}
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)
)
definition = (
	toggle:: collapsed: [collapsedDefinition]
		expanded: [expandedDefinition].
	^toggle
)
editorDefinition = (
	| src = crToLf: subject classHeaderSource. editor =  codeMirror: src. |
	editor changeResponse: changeResponse;
		acceptResponse: acceptResponse.
	colorizeHeaderSource: src withEditor: editor.
	^editor
)
expandedDefinition = (
  ^column: {
      headerDefinition.
	editorDefinition.
	}
)
headerDefinition ^ <Fragment> = (
  ^row: {
      image: (iconForAccessModifier: subject accessModifier).
      blank: 3.
      (link: subject name action: [toggle toggle]) color: actionLinkColor.
	filler.
	dropDownMenu: [methodMenuFor: subject name]
   }.
)
public isKindOfClassFactoryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassFactoryPresenter
)
slotList ^ <Fragment> = (
  | sl |
	^column: {
           (sl:: subject classMirror instanceSide slots) size > 0
		   ifTrue: [
			column: {
				label: 'Slots'.
				row: {
					mediumBlank.
					column: (sl collect: [:ea | label: ea name]).
				}
			}.
		] ifFalse: [nothing].
		}
)
) : (
)
class ClassFactorySubject onModel: m <ClassDeclarationMirror> = MethodSubject onModel: m (
(* WIP. *)
) (
public accessModifier ^ <Symbol> = (
	^#public
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classCommentText ^<String> = (
	| comment = classMirror header classComment. |
	nil = comment ifTrue: [^''].
	^comment
)
public classHeaderSource = (
	^classMirror header source
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter ^ <ClassFactoryPresenter> = (
	^ClassFactoryPresenter onSubject: self
)
public delete = (
	Error signal: 'cannot delete primary class factory'
)
public isKindOfClassFactorySubject ^ <Boolean> = (
  true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfClassFactorySubject
)
public name ^ <Symbol> = (
 ^classMirror primaryFactorySelector
)
) : (
)
class ClassPresenter onSubject: s = ProgrammingPresenter onSubject: s (
|
descriptionOrSourceSwitcherHolder
descriptionOrSourceHolder
|
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> |
		| b <ClassDeclarationBuilder> = subject classMirror asBuilder. |
		(*('ed text:', ed textBeingAccepted) out.*)
		b header source: ed textBeingAccepted.
		b install.
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed leaveEditState.
		]
)
accessIndicator = (
	^image: (iconForAccessModifier: subject accessModifier).
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event>  |
		colorizeHeaderSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed enterEditState.
	  ]
)
classActionsMenu = (
	^menuWithLabelsAndActions: {
	 	{'Save to File'. [respondToSave]}.
		{'Inspect Mirror'. [inspectObject: subject classMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
		{'Delete'. [respondToDelete]}.
	}
)
classCommentSummary ^ <String> = (
	|
	fullComment <String> = subject classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
classDescriptionDefinition = (
	| slotList <Fragment> |
	^column: {
		ClassCommentPresenter onSubject: subject.
		mediumBlank.
           (slotList:: subject classMirror instanceSide slots) size > 0
		   ifTrue: [
			column: {
				label: 'Slots'.
				row: {
					mediumBlank.
					column: (slotList collect: [:ea | label: ea name]).
				}
			}.
		] ifFalse: [nothing].
		initializerDefinition.
		}
)
classNameAndContainmentDefinition ^ <Fragment> = (
	^column: {
		classNameAndHierarchySummary.
		preambleLine.
		label: subject classCommentSummary.
	}
)
classNameAndHierarchySummary = (
	| parts <List[Fragment]> |
	parts:: List new.
	subject enclosingClassSubjects
		do: [:ecs | parts add: (link: ecs name action: [enterSubject:: ecs])]
		separatedBy: [parts add: ( label: ' in ')].
	^column: {
		row: {
			blank: 5.
			image: ide images classIcon.
			blank: 5.
			row: parts.
			filler.
			ClassActionsPresenter onSubject: subject.
			smallBlank.
			dropDownMenu: [classActionsMenu].
			largeBlank.
			homeButton.
			smallBlank.
			refreshButton.
			smallBlank.
		}
	}
)
classSourceDefinition = (
	| src = crToLf: subject classHeaderSource. editor =  codeMirror: src. |
	editor changeResponse: changeResponse;
		acceptResponse: acceptResponse.
	colorizeHeaderSource: src withEditor: editor.
	^editor
)
colorizeHeaderSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeHeader: s fromClass: subject classMirror via: (colorizingBlockFor: cm)
)
public definition ^ <Fragment> = (
	^column: {
		headingDefinition.
		subject nestedClassesSubject presenter.
		subject methodsSubject presenter.
		subject classMethodsSubject presenter.
	}
)
expandedHeadingDefinition ^ <Fragment> = (
  ^column: {
      classNameAndHierarchySummary.
      (ClassFactorySubject onModel: subject classMirror) presenter
   }
)
headingDefinition ^ <Fragment> = (
	^(column: {
		expanded: [expandedHeadingDefinition]
		collapsed: [classNameAndHierarchySummary].
	}) color: (Color h: 240 s: 0.05 v: 0.9).
)
initializerDefinition ^ <Fragment> = (
	^nothing
)
inspectSelf ^ <Fragment> = (
	^row: {filler. link: 'Inspect Presenter' action: [enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: self)]}
)
public isKindOfClassPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfClassPresenter
)
minorClassHeadingBlock: body = (
	^(padded: body with: {10. 5. 10. 5.})
		color: minorClassHeadingColor
)
minorClassHeadingColor = (
	^Gradient
		from: (Color h: 240 s: 0.02 v: 0.94)
		to: (Color h: 240 s: 0.02 v: 0.9)
)
nestedClass: cdm = (
	^collapsed: [row: {
					image: (iconForAccessModifier: cdm accessModifier).
					blank: 3.
					link: cdm simpleName action: [enterSubject:: ClassSubject onModel: cdm]
					}
				]
	expanded: [(ClassSubject onModel: cdm) presenter]
)
preambleLine = (
	(* The line showing the class constructor syntax, e.g. 'Foo foo: x = Bar'. The superclass clause, if present, becomes a link to browse the superclass. *)

	| preamble <String> equalIndex <Integer> prefix <String> suffix <String> |
	preamble:: subject classMirror header preamble.
	equalIndex:: preamble indexOf: "=".
	equalIndex = 0
		ifTrue:
			[prefix:: preamble.
			suffix:: '']
		ifFalse:
			[prefix:: (preamble copyFrom: 1 to: equalIndex - 1).
			suffix:: (preamble copyFrom: equalIndex + 1 to: preamble size)].
	^suffix isEmpty
		ifTrue:
			[label: prefix]
		ifFalse:
			[row: {
				label: prefix, ' = '.
				link: suffix action: [respondToBrowseSuperclass]
				}]
)
respondToDelete = (
	| enclosing = subject enclosingClassSubject. |
	subject deleteClass.
	enterSubject: enclosing.
)
respondToSave = (
	downloadFileName: subject name, '.ns' fromString: subject classMirror source. 
)
) : (
)
public class ClassSubject onModel: m <ClassDeclarationMirror> = Subject onModel: m (
) (
public accessModifier = (
	^classMirror accessModifier
)
public classCommentSummary ^ <String> = (
	|
	fullComment <String> = classCommentText.
	endOfFirstSentence <Integer> = fullComment indexOf: '.'.
	firstSentence <String> = fullComment copyFrom: 1 to: endOfFirstSentence.
	|
	^firstSentence
)
public classCommentText ^<String> = (
	| comment = model header classComment. |
	nil = comment ifTrue: [^''].
	^comment
)
public classHeaderSource = (
	^classMirror header source
)
public classMethodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror classSide methods within: classMirror classSide
)
public classMirror ^ <ClassDeclarationMirror> = (
	^model
)
public createPresenter = (
	^ClassPresenter onSubject: self
)
public deleteClass = (
	| builder |
	nil = model enclosingClass ifTrue: [halt].
	builder:: model enclosingClass asBuilder.
	builder instanceSide nestedClasses removeMirrorNamed: model name.
	builder install.
)
public enclosingClassSubject ^ <ClassSubject> = (
	^ClassSubject onModel: model enclosingClass
)
public enclosingClassSubjects ^ <List[ClassSubject]> = (
	| them = List new. c |
	c:: model.
	[c isNil] whileFalse: [them add: (ClassSubject onModel: c). c:: c enclosingClass].
	^them
)
public isKindOfClassSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfClassSubject
)
public isTestConfiguration = (
	(* bogus, but compatible. *)
	^isTopLevel and: [(model header source indexOf: 'packageTestsUsing:') > 0]
)
public isTopLevel = (
	^nil = model enclosingClass
)
public methodsSubject ^ <MethodGroupSubject> = (
	^MethodGroupSubject onModel: classMirror instanceSide methods within: classMirror instanceSide
)
public name = (
	^model name
)
public nestedClassesSubject ^ <NestedClassGroupSubject> = (
	^NestedClassGroupSubject onModel: classMirror instanceSide nestedClasses within: classMirror instanceSide
)
public testingSubject = (
	#NAMESPACEBOGUS.
	^ide minitestUI TestingInProgressSubject
		onConfiguration: (ide namespacing Root at: name)
		platform: cachedPlatform
		minitest: ide minitest
)
public title = (
	^name
)
) : (
)
public class DefinitionListPresenter onSubject: s = ProgrammingPresenter onSubject: s (
(* 
DefinitionListPresenter is an abstract superclass of presenters that displays helper ''transient'' presenters that visually appear to belong to the main list of subject presenters. One common example is a method list presenter which can at times include presenters for methods being added. 
*)

| 
stateSlot <DefinitionListPresenterState> 
contentListSlot <ToggleList>
|
) (
addButton = (
  ^addButtonWithAction: [updateGUI: [respondToAdd]].
)
public addNewItemTemplate = (
	(* A subclass must redefine this to show a template for the user to fill out to create a new item in the group. *)

	subclassResponsibility
)
public collapseAll = (
	(* Collapse all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	contentList childrenDo: [:each <ToggleComposer> | each collapse]
)
contentList = (
   contentListSlot isNil ifTrue: [
	contentListSlot:: toggleList: contentPresenters
	].
  ^contentListSlot.
)
definition ^ <Fragment> = (
	^column: {
		minorHeadingBlock: (
			row: {
				label: title (*asText allBold*).
				largeBlank.
				addButton.
				filler.
				expandButtonWithAction: [expandAll].
				blank: 3.
				collapseButtonWithAction: [collapseAll].
				blank: 3.
				dropDownMenu: [definitionListMenu].
				largeBlank.
				homeButton.
				smallBlank.
				refreshButton.
				}
			).
		mediumBlank.
		state prefixHolder.
		mediumBlank.
		contentList.
		mediumBlank.
	}
)
definitionListMenu = (
  subclassResponsibility
)
public expandAll = (
	(* Expand all presenters in the content list. This operation depends on the type of content elements, so it is applicable often but not always. Still, it's handy to have it here available for reuse. *)

	contentList childrenDo: [:each <ToggleComposer> | each expand]
)
public isKindOfDefinitionListPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDefinitionListPresenter
)
respondToAdd = (
  addNewItemTemplate
)
public state = (
  stateSlot isNil ifTrue: [stateSlot:: DefinitionListPresenterState new].
  ^stateSlot
)
public title = (
  subclassResponsibility
)
updateVisualsFromSameKind: oldPresenter <Self> ^ <Alien[Element]> = (
  stateSlot:: oldPresenter state.
  substanceSlot:: nil.
  ensureSubstance.
  ^super updateVisualsFromSameKind: oldPresenter
)
) : (
)
public class DefinitionListPresenterState = (
  | 
  prefixes <List[DefinitionTemplate]> = List new. 
  prefixPresenter = PrefixPresenter new.
  public prefixHolder <HolderComposer> = prefixPresenter holder: fragmentForPrefixes. 
  |
) (
class PrefixPresenter = Presenter onSubject: nil (
(*
A trick/hack to give the enclosing object access to the the fragment factories it needs.
The only way to create fragments outside the Hopscotch module is via the factories inherited from Presenter.
DefinitionListPresenterState is not a presenter, and yet it manufactures bits of presentation. Hence, we create
this presenter class, which publicizes the required inherited factories. Each factory has a single instance of this class,
which it uses to access the needed factories.
*)
) (
public column: ds  <List[Fragment]> ^ <ColumnComposer>  = (
  ^super column: ds
)
public holder: c <Fragment> ^ <HolderComposer> = (
  ^super holder: c
)
public isKindOfPrefixPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfPrefixPresenter
)
) : (
)
public addPrefix: p <DefinitionTemplate> = (
  prefixes add: p.
  updatePrefixes.
)
fragmentForPrefixes ^ <Fragment> = (
  ^prefixPresenter column: prefixes
)
public isKindOfDefinitionListPresenterState ^ <Boolean> = (
  ^true
)
public removePrefix: p <DefinitionTemplate>  = (
  prefixes remove: p.
  updatePrefixes.
)
updatePrefixes = (
  prefixHolder isNil ifFalse: [prefixHolder content: fragmentForPrefixes]
)
) : (
)
public class DefinitionListSubject onModel: m = Subject onModel: m (
(* DefinitionListSubject is manages helper ''transient'' subjects, for example is a method list  which can at times include presenters for methods being added or residue presenters of removed methods. *)
| 
public prefixes <List[Fragment]> = List new.
public content <List[Subject]>  = List new. 
|
) (
public createPresenter ^ <DefinitionListPresenter> = (
  ^DefinitionListPresenter onSubject: self.
)
public isKindOfDefinitionListSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfDefinitionListSubject
)
public resetPresenters = (
  super resetPresenters.
  content do: [:s <Subject> | s  resetPresenters].
)
) : (
)
public class DefinitionTemplate
   caption: c <String>
   initialText: t <String | Text>
   colorizerBlock: cb <[:String :CodeMirrorFragment]>
   acceptResponse: onAccept <[DefinitionTemplate]>
   cancelResponse: onCancel <[DefinitionTemplate]>
 = ProgrammingPresenter onSubject: nil (|
	public caption = c.
	public initialText = t.
	public initiallyInEditState ::= true.
	public acceptResponse = onAccept.
	public cancelResponse = onCancel.
	public editor
	public colorizerBlock = cb.
|) (
public = other <Object>^ <Boolean> = (
  other isKindOfDefinitionTemplate ifFalse: [^false].
  ^other text = text
)
definition ^ <Fragment> = (
	^(row: {
		mediumBlank.
		elastic:
			(column: {
				smallBlank.
				label: caption.
				editorDefinition.
				mediumBlank.
 			}).
		smallBlank.
		}) color: (Gradient from: (Color h: 100 s: 0.3 v: 0.9) to: (Color h: 100 s: 0.3 v: 0.8))
)
editorDefinition ^ <Fragment> = (
	editor:: (codeMirror: initialText)
	(*	acceptLabelText: 'save';
		cancelLabelText: 'cancel';*)
		acceptResponse: [acceptResponse value: self];
		changeResponse: [:cm <CodeMirrorFragment> :event <Event>  | colorizerBlock value: cm textBeingAccepted value: cm];
		cancelResponse: [cancelResponse value: self].
	initiallyInEditState ifTrue: [editor enterEditState].
	colorizerBlock value: initialText value: editor.
	^editor
)
public hash ^ <Integer> = (
  ^text hash
)
public isKindOfDefinitionTemplate ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfDefinitionTemplate
)
public tag ^ <String> = (
  ^printString
)
public text = (
	^editor textBeingAccepted
)
) : (
)
class EntryPresenter onSubject: s = ProgrammingPresenter onSubject: s () (
public collapse = (
	substance collapse
)
definition = (
	^collapsed: [collapsedDefinition] expanded: [expandedDefinition]
)
public expand = (
	substance expand
)
public isKindOfEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfEntryPresenter
)
row1: row1 row2: row2 = (
	^row: {
		(row: row1) width: 0 elasticity: 1.
		(row: {mediumBlank}, row2) width: 0 elasticity: 2.
	}
)
) : (
)
public class EvaluationPresenter onSubject: s <EvaluationViewState> = ProgrammingPresenter onSubject: s (
| cm <CodeMirrorFragment> |
) (
changeResponse = (
  ^subject isLive ifTrue: [liveChangeResponse] ifFalse: [deadChangeResponse]
)
deadChangeResponse = (
  ^[:editor <CodeMirrorFragment>  | | src <String> =  editor textBeingAccepted. |
	ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor).
	editor isInEditState: true.
	editor editor focus.
   ].
)
definition = (
	^column: {
	      row: {
	         button: 'Evaluate Selection' action: [updateGUI: [subject evaluate: (withoutNbsp: cm editor getSelection)]].
	         invertEvalStatusButton.
	      }.
		editorDefinition.
		column: results.
	}
)
editorDefinition ^ <CodeMirrorFragment> = (
	| initialSource |
	initialSource:: ''.
	cm:: (codeMirror: initialSource) changeResponse: changeResponse.

	(* ide colorizer colorizeDoIt: initialSource fromClass: nil via: (colorizingBlockFor: cm).*)
	^cm
)
invertEvalStatusButton ^ <ButtonFragment> = (
  ^subject isLive ifTrue: [
	 button: 'Suspend Live Evaluation' action: [updateGUI: [subject isLive: false]]
	 ] ifFalse: [ button: 'Start Live Evaluation' action: [updateGUI: [subject isLive: true]]]
)
public isKindOfEvaluationPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfEvaluationPresenter
)
linkForCompileError: error <Exception> = (
	^column: {
		smallBlank.
		(link: error printString action:
			[inspectObjectMirror: (ObjectMirror reflecting: error)])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForError: thread <ThreadMirror> = (
	^column: {
		smallBlank.
		(link: thread result reflectee printString action:
			[enterSubject:: ide debugging ThreadSubject onModel: thread])
				color: (Color r: 1 g: 0 b: 0).
	}
)
linkForEvaluation: r ^ <Fragment> = (
  r isKindOfError ifTrue: [:e | ^linkForCompileError: e].
  r isFulfilled ifTrue: [^linkForResult: r].
  r isBroken ifTrue: [^linkForError: r]. 
 'result is neither error nor fulfilled nor broken!' out.
)
linkForResult: r ^ <Fragment> = (
	^column: {
		smallBlank.
		(link: r result reflectee printString action:
			[enterSubject:: ObjectSubject onModel: r result]).
	}
)
linkForThread: thread <ThreadMirror> ^ <Fragment> = (
	thread isFulfilled ifTrue: [^linkForResult: thread].
	thread isBroken ifTrue: [^linkForError: thread].
	^nothing
)
liveChangeResponse = (
  ^[:editor <CodeMirrorFragment>  | | src <String> =  editor textBeingAccepted. |
	updateGUI: [
		subject evaluateLive: (withoutNbsp: src).
		ide colorizer colorizeDoIt: src fromClass: nil via: (colorizingBlockFor: editor).
		editor isInEditState: true.
		].
	editor editor focus.
   ].
)
results ^ <List[Fragment]> = (
  ^subject results collect: [:r | r isKindOfThreadMirror ifTrue: [linkForThread: r] ifFalse: [linkForCompileError: r]]
)
withoutNbsp: string = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 160 ifTrue: [bytes at: index put: 32]].
			^bytes asString]
		ifFalse:
			[ | nonbreakingSpace = String fromRune: 160.
			space = String fromRune: 32. |
			^string replaceAll: nonbreakingSpace with: space]
)
) : (
)
public class EvaluationViewState onModel: m <ObjectSubject | ActivationSubject> = Subject onModel: m (
(* An evaluator maintains a list of results of prior evaluations. *)
  | results_slot <List[ThreadMirror]> = List new. lastEvalWasLive <Booleean> ::= false. public isLive <Boolean> ::= true. |
) (
public clear = (
  results_slot:: List new
)
public createPresenter ^ <Presenter> = (
  ^EvaluationPresenter onSubject: self
)
public evaluate: e <String> ^ <ThreadMirror>  = (
  lastEvalWasLive:: false.
  ^results_slot add: ([model evaluate: e] on: Error do: [:ce | ce])
)
public evaluateLive: e <String> ^ <ThreadMirror>  = (
  | result = [model evaluate: e] on: Error do: [:ce | ce]. |
  ^lastEvalWasLive ifTrue: [
	e last = '.' last ifTrue: [lastEvalWasLive:: false]. (* if e is empty we get a crash *)
	results_slot at: results_slot size put: result.
	]  ifFalse: [lastEvalWasLive:: e last  ~= '.' last. results_slot add: result]
)
public isKindOfEvaluationViewState ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfEvaluationViewState
)
public results  ^  <List[ThreadMirror]> = (
  ^results_slot
)
) : (
)
class HomePresenter onSubject: s = ProgrammingPresenter onSubject: s (
) (
aboutSystemDefinition = (
	^(link: 'About this system' action: [respondToAboutSystem]) smallFont.
)
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
column1: definitions1 column2: definitions2 column3: definitions3 = (
	^row: {
		(column: definitions1) width: 0 elasticity: 1.
		(column: definitions2) width: 0 elasticity: 1.
		(column: definitions3) width: 0 elasticity: 1.
	}
)
definition = (
	^column: {
	      helpSection.
		majorHeadingBlock: (
			row: {
				label: 'Navigation'.
				filler.
                        dropDownMenu: [actionsMenu].
                        mediumBlank.				
				helpButton.
			}
		).
		mediumBlank.

		indentedBlock:
			(column1: {
				link: 'Newspeak Source' action: [navigateToNamespace].
			}
			column2: {
				link: 'Workspaces' action: [navigateToWorkspaces].
			}
			column3: {
			}).
		mediumBlank.

(*		majorHeadingBlock: (label: 'Recently Visited' asText allBold).
		mediumBlank.
		indentedBlock:
			(holder: [recentStuffDefinition]).
		largeBlank.*)

		majorHeadingBlock: (label: 'Did you know?').
		mediumBlank.

		indentedBlock:
			(holder: [didYouKnow]).
		mediumBlank.
		indentedBlock: aboutSystemDefinition.
	}
)
didYouKnow = (
	| wisdom |
	wisdom:: subject randomBitOfWisdom.
	nil = wisdom actionLabel ifFalse:
		[^textAndActionWisdom: wisdom].
	nil = wisdom image ifFalse:
		[^textAndImageWisdom: wisdom].
	^textDisplay: wisdom text
)
helpButton = (
  ^(link: '[?]' action: [updateGUI: [subject helpActive: true]]) smallFont
)
helpSection = (
  ^subject helpActive ifTrue: [
	column: {
		row: {
		      filler.
			(link: 'close help' action: [updateGUI: [subject helpActive: false]]) smallFont.
		}.
		textDisplay: subject helpText.
	}
	] ifFalse: [nothing]
)
public isKindOfHomePresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfHomePresenter
)
navigateToNamespace = (
	enterSubject:: NamespaceSubject new.
)
navigateToWorkspaces = (
	enterSubject:: ide theWorkspaceManager AllWorkspacesSubject new.
)
respondToAboutSystem = (
	alert: 'WebIDEApp version 0.1984'
)
textAndActionWisdom: wisdom = (
	^column: {
		textDisplay: wisdom text.
		(link: wisdom actionLabel action: wisdom actionBlock) smallFont
	}
)
textAndImageWisdom: wisdom = (
	^row: {
		image: wisdom image.
		mediumBlank.
		elastic:
			(textDisplay: wisdom text).
	}
)
) : (
)
public class HomeSubject onModel: m = Subject onModel: m () (
public = anotherSubject <Subject> ^ <Boolean> = (
	(* As there is just one possible logical home of the system, all subjects representing it are considered equal. *)
	^anotherSubject isKindOfHomeSubject
)
bitsOfWisdom = (
	(* This defines the bits of wisdom displayed at the bottom of the Hopscotch home page. Each time a page opens a new element is selected at random. An element may evaluate to nil, which will select another element at random. *)
	^{
	[BitOfWisdom
		text: 'This is the "expand all" button which appears in headers of expandable item groups.'
		image: ide images expandImage].

	[BitOfWisdom
		text: 'This is the "collapse all" button which appears in headers of expandable item groups.'
		image: ide images collapseImage].

	[BitOfWisdom
		text: 'This is the "add" button which appears in headers of groups of items you can add to, such as methods of a class or classes of a package.'
		image: ide images addImage].

	[BitOfWisdom
		text: 'Expressions evaluated in debuggers and inspectors can access a workspace via the name _. This allows you to bypass modularity during development and access values you forgot to import, e.g. _ collections List.'].

	[BitOfWisdom
		text: 'This icon identifies Newspeak classes.'
		image: ide images classIcon].

	[BitOfWisdom
		text: 'This icon identifies namespaces.'
		image: ide images classPresenterIcon].

	[BitOfWisdom
		text: 'War is peace. Freedom is slavery. Ignorance is strength.'].
	}
)
public createPresenter = (
	^HomePresenter onSubject: (HomeViewSubject onModel: self)
)
public isKindOfHomeSubject ^ <Boolean> = (
	^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfHomeSubject
)
public randomBitOfWisdom = (
	| bits = bitsOfWisdom. |
	^(bits at: (JSMath random * bits size) floor asInteger + 1) value
)
public resetPresenters = (
 #BOGUS. (* really, this method should do nothing. *)
 super resetPresenters
)
public title = (
	^'Home'
)
) : (
public new = (
	^onModel: nil
)
)
public class HomeViewSubject onModel: s  <HomeSubject> = Subject onModel: s (
(* The Home presentation is stateful. This subject captures thay state. In practice, the Home presentation is so simple that
    having a separate view-subject is questionable, but it cleanly separates client-local state (in fact, that state is simply whether the
    help text is displayed or not. This more of a pilot to tets out a structure with a separate view-subject.
 *)
|
	public helpActive ::= false.
|
) (
public = anotherSubject ^<Boolean> = (
	(* All home view subjects are considered the same so that clicking the home button always takes us to the same page instead of multiplying them. *)
	^anotherSubject isKindOfHomeViewSubject
)
public createPresenter = (
	^HomePresenter onSubject: self
)
public hash ^<Integer> = (
	^self class hash
)
public helpText ^<String | nil> = (
  ^'This is the home page.
The home page includes links to a variety of useful places, like the IDE''s root namespace, which lists all top level classes, and the workspace manager, where you can evaluate code.
Golden icons represent Newspeak3, which is the currently operational dialect of Newspeak.'
)
public isKindOfHomeViewSubject ^ <Boolean> = (
	^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfHomeViewSubject
)
public randomBitOfWisdom  = (
  ^model randomBitOfWisdom
)
) : (
)
class IntegerView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	^column: {
		label: 'binary' radix: 2.
		label: 'octal' radix: 8.
		label: 'decimal' radix: 10.
		label: 'hex' radix: 16.
	}
)
public isKindOfIntegerView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfIntegerView
)
label: label radix: radix = (
	^row: {
		smallBlank.
		(label: label)
			width: 0 elasticity: 1.
		smallBlank.
		(label: (subject objectMirror reflectee asStringRadix: radix))
			width: 0 elasticity: detailAreaRatio.
	}
)
) : (
)
class KeysAndValuesView title: t onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public title <String> = t.
	|
) (
public definition = (
	^column:
		(subject keysAndValues collect:
			[:slot <SlotSubject> | slot presenter])
)
public isKindOfKeysAndValuesView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfKeysAndValuesView
)
) : (
)
class MethodGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, an NSMethodGroup, as a column of presenters for the methods in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS methods goes here. *)
| groupedByCategory <Boolean> ::=false. |
) (
public addNewItemTemplate = (
	(* Handle a user's request to create a new method by displaying a new method template. *)
	addNewItemTemplate: subject methodTemplateText
)
addNewItemTemplate: src = (
	(* Handle a user's request to create a new method by displaying a new method template. *)

	| template prefixState <DefinitionLisPresenterState> = state. |
	template:: DefinitionTemplate
		caption: 'Adding new method:'
		initialText: src
		colorizerBlock:
			[:text <String> :cm <CodeMIrrorFragment> | subject colorizeSource: text editor: cm]
		acceptResponse:
			[:ed | createNewMethodFromTemplate: template]
		cancelResponse:
			[:ed | updateGUI: [prefixState removePrefix: template]].
	prefixState addPrefix: template
)
createNewMethodFromTemplate: template <DefinitionTemplate> = (
| prefixState <DefinitionListPresenterState> = state. |
	subject
		compileSource: template text
		ifSuccess:
			[:newMethod <MethodMirror> |
			|
			(* newSubject <MethodSubject> = MethodSubject onModel: newMethod.
			newPresenter <MethodPresenter> = createPresenterForSubject: newSubject.*)
			(*newToggle <ToggleComposer> = newPresenter visual; substance.*)
			|

			prefixState removePrefix: template.
			updateGUI: []
			]
		ifFailure:
			[:message | template editor showMessage: message]
)
public deleteMethodInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	updateGUI: [
		subject deleteMethodWithSubject: presenter subject.
		successResponse value
		]
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^MethodPresenter
)
public title = (
  | side = subject definingMixin isMeta ifTrue: ['Class'] ifFalse: ['Instance'].|
  ^side, ' Methods'
)
) : (
)
public class MethodGroupSubject onModel: m <MirrorGroup[MethodMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
(* Represents the collection of methods of a Newspeak class. Holds onto the mirror group for the methods. *)
) (
public colorizeSource: source <String> editor: cm <CodeMirrorFragment> ^ <TextFragment> = (
	^ide colorizer
		colorizeMethod: source
		fromClass: definingMixin declaration
		via: (colorizingBlockFor: cm)
)
public compileSource: source <String> ifSuccess: successBlock <[:MethodMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <MethodBuilder> newMirror <MethodMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder methods addFromSource: source.
	builder declaration install.
	newMirror:: definingMixin methods findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public createPresenter = (
	^MethodGroupPresenter onSubject: self
)
public deleteMethodWithSubject: methodSubject <MethodSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder methods removeMirrorNamed: methodSubject selector.
	builder declaration install.
)
elementSubjectClass ^ <MethodSubject class> = (
	^MethodSubject
)
public isKindOfMethodGroupSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfMethodGroupSubject
)
public methodTemplateText ^ <String> = (
^
'messageSelector = (
)'
)
modelMirrorCollection ^ <Collection[MethodMirror]> = (
	^super modelMirrorCollection (*asSortedList: [:a :b | a simpleName < b simpleName]*)
)
) : (
)
class MethodPresenter onSubject: s <MethodSubject> = ProgrammingPresenter onSubject: s (
	(* A presenter for a single method. *)
	|
	public showClassName ::= false.
	|
) (
acceptResponse ^ <[:CodeMirrorFragment :Event]> = (
	^ [:ed <CodeMirrorFragment> :event <Event> |
		| b <MixinBuilder> = subject methodMirror definingMixin asBuilder. |
		updateGUI: [
			b methods addFromSource: ed textBeingAccepted.
			b declaration install.
			colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
			ed leaveEditState.
			].
		ed editor focus.
		]
)
changeResponse ^ <[:CodeMirrorFragment :Event]> = (
	^[:ed <CodeMirrorFragment> :event <Event> | | cp <Integer> |
		colorizeMethodSource: (crToLf: ed textBeingAccepted) withEditor: ed.
		ed enterEditState.
	 ]
)
public collapse = (
	^substance collapse
)
colorizeMethodSource: s <String> withEditor: cm <CodeMirrorFragment> = (
	ide colorizer colorizeMethod: s fromClass: subject classDeclaration via: (colorizingBlockFor: cm)
)
public definition ^ <Fragment> = (
	| toggle |
	toggle::
		collapsed: [row: {
			image: (iconForAccessModifier: subject accessModifier).
			blank: 3.
			(link: subject name action: [toggle expand]) color: actionLinkColor.
	        filler.
	        dropDownMenu: [methodMenuFor: subject name]
			}
		]
		expanded: [ |  src = crToLf: subject source. cm = codeMirror: src. |
			cm changeResponse: changeResponse; acceptResponse: acceptResponse.
			colorizeMethodSource: src withEditor: cm.
			column: {
			row: {
			  image: (iconForAccessModifier: subject accessModifier).
			  blank: 3.
			  (link: subject name action: [toggle collapse]) color: actionLinkColor.
	          filler.
	          dropDownMenu: [methodMenuFor: subject name]
			}.
			cm
		}].
	^toggle
)
public expand = (
	^substance expand
)
public isKindOfMethodPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfMethodPresenter
)
methodMenuFor: methodName <String> = (
	^menuWithLabelsAndActions: {
		{'Delete ', methodName. [updateGUI: [subject delete. (* refresh *)]]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}
	}
)
public tag ^ <String> = (
  ^subject name
)
) : (
)
public class MethodSubject onModel: mm <MethodMirror> = Subject onModel: mm (
(* Manages the UI for a method. *)
) (
public accessModifier ^ <Symbol> = (
	^methodMirror accessModifier
)
public classDeclaration ^ <ClassDeclarationMirror> = (
	^methodMirror definingMixin declaration
)
public createPresenter ^ <Presenter> = (
	^MethodPresenter onSubject: self
)
public delete = (
	| b <MixinBuilder> = methodMirror definingMixin asBuilder. |
	b methods removeMirrorNamed: methodMirror name.
	b declaration install.
)
public methodMirror ^ <MethodMirror> = (
	^model
)
public name ^ <Symbol> = (
	^methodMirror name
)
public source ^ <String> = (
	^methodMirror source
)
) : (
)
class MirrorGroupPresenter onSubject: s <Subject> = DefinitionListPresenter onSubject: s (
) (
contentPresenters ^ <Collection[ProgrammingPresenter]> = (
	^subject elements collect:
		[:each <ProgrammingPresenter> | createPresenterForSubject: each]
)
createPresenterForSubject: aSubject <Subject> ^ <ProgrammingPresenter> = (
	(* Let the subject create its default unless elementPresenterClass is set to specify our preference. *)
	nil = elementPresenterClass ifTrue: [^aSubject presenter].
	^elementPresenterClass onSubject: aSubject
)
definitionListMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}
	}
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	(* A subclass must redefine this to define the class of presenter it will be using. *)
	subclassResponsibility
)
) : (
)
class MirrorGroupSubject onModel: m <MirrorGroup> within: dm <MixinMirror> = Subject onModel: m (
	|
	public definingMixin <MixinMirror> = dm.
	|
) (
elementSubjectClass = (
	(* Answer the class of the subjects we create on individual elements of our subject group. *)
	subclassResponsibility
)
public elements ^<Collection[Subject]> = (
	(* Answer a collection of subjects on individual elements of the group which is our subject. *)
	^modelMirrorCollection collect: [:each | elementSubjectClass onModel: each]
)
public isKindOfMirrorGroupSubject ^ <Boolean> = (
  ^true
)
public mirrorGroup ^ <MirrorGroup> = (
	^model
)
modelMirrorCollection ^<Collection[Mirror]> = (
	^List withAll: model
)
) : (
)
class NamespacePresenter onSubject: s = DefinitionListPresenter onSubject: s (
) (
class ClassEntryPresenter onSubject: s <ClassSubject> = outer SimpleBrowsing ClassEntryPresenter onSubject: s () (
accessIndicator = (
	^nothing
)
entryActionsMenu = (
	^dropDownMenu: [entryActionsMenuFor: subject name].
)
) : (
)
class NamespaceEntryPresenter onSubject: s = EntryPresenter onSubject: s () (
collapsedDefinition = (
	^row1: {
		image: ide images classPresenterIcon.
		smallBlank.
		row: {link: subject key action: [
			(*ide defaultPopularityRecord
			rememberNamespaceVisit: subject key. (* Should be the namespace itself, but non-strings break the home page. *)*)
			enterSubject:: subject refreshmentSubject]}.
	} row2: {
		(label: subject summaryText)
				smallFont;
				compressibility: 1;
				color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: subject key]
	}.
)
expandedDefinition = (
	^subject presenter
)
public tag ^ <String> = (
  ^subject key
)
) : (
)
class ValueEntryPresenter onSubject: s = EntryPresenter onSubject: s (|
	public key
|) (
collapsedDefinition = (
	^row1: {
		image: ide images classUnknownIcon.
		smallBlank.
		link: key action: [enterSubject:: subject].
	} row2: {
		(label: subject title)
			smallFont;
			compressibility: 1;
			color: secondaryTextColor.
		filler
			compressibility: 0.
		mediumBlank.
		dropDownMenu: [entryActionsMenuFor: key]
	}
)
definition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^collapsed: [collapsedDefinition]
	expanded: [subject presenter selfCaption: key]
)
expandedDefinition = (
	(* Should provide someway to edit the value. Possibly like the slots experiment with the inspectors. Evaluate in the context of a workspace. *)
	^subject presenter selfCaption: key
)
public isKindOfValueEntryPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfValueEntryPresenter
)
public tag ^ <String> = (
  ^key
)
) : (
)
acceptNewClassDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[updateGUI: [prefixState removePrefix: aTemplate]]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
acceptNewNamespaceDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addNamespaceFromDefinition: aTemplate text
		ifSuccess:
			[updateGUI: [prefixState removePrefix: aTemplate]]
		ifFailure:
			[:msg | aTemplate editor text: msg]
)
addButton = (
		^(*subject namespace isKindOfCategoryNamespace
				ifTrue: [*)addButtonWithMenu: [addCategoryMenu](*]
				ifFalse: [addButtonWithAction: [respondToAddForRoot]]*).
)
addCategoryMenu = (
	^ {
		{'Add Class'. [addClassTemplate]}.
		{ 'Add Namespace'. [addNamespaceTemplate]}.
		(*{'Add Image From File'. [respondToAddImage].}.
		{'Add Text From File'. [respondToAddText]}.
		 'Add Value' -> [Error signal: 'Unimplemented']. *)
	}
)
addClassTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
addNamespaceTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	updateGUI: [prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new namespace:'
			initialText: 'NewNamespace'
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | ]
			acceptResponse:
				[:template | acceptNewNamespaceDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]])].
)
contentList ^ <PresenterList> = (
	^zebra: super contentList
)
contentPresenters ^ <List[Presenter]> = (
	| lexicalOrder <[:Symbol :Symbol | Boolean]> |
	lexicalOrder:: [:a <Symbol> :b <Symbol> |
		lexicallyLessOrEqual: a than: b
	].
	^(subject namespace keys asArray sort: lexicalOrder) collect: [:key | presenterForEntryAt: key]
)
definitionListMenu = (
  ^namespaceMenu
)
entryActionsMenuFor: key = (
	^menuWithLabelsAndActions: {
		{'Remove ', key. [updateGUI: [ide namespacing removeKey: key.]]}.
	}
)
public isKindOfNamespacePresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfNamespacePresenter
)
lexicallyLessOrEqual: a <String> than: b <String> ^ <Boolean> = (
	(* BOGUS: This should be a utility somewhere *)
	| length = a size min: b size. |
	('a' at: 1) isKindOfInteger ifTrue: 
		[1 to: length do:
			[:index |
			 (a at: index) < (b at: index) ifTrue: [^true].
			 (a at: index) > (b at: index) ifTrue: [^false]].
		^true].

	1 to: length do:
		[:index |
		 (a runeAt: index) < (b runeAt: index) ifTrue: [^true].
		 (a runeAt: index) > (b runeAt: index) ifTrue: [^false]].
	^true
)
namespaceMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Presenter' . [respondToInspectPresenter]}.
		{'Compile File'. [respondToCompileFile]}
	}
)
presenterForEntryAt: key <Symbol> ^ <EntryPresenter> = (
	| entry = subject namespace at: key. |
	entry isKindOfBehavior
		ifTrue: [^ClassEntryPresenter onSubject: (ClassSubject onModel: (ClassMirror reflecting: entry) mixin declaration)].

	entry isKindOfNamespace
		ifTrue: [^NamespaceEntryPresenter onSubject: (NamespaceSubject onModel: entry key: key)].

	^(ValueEntryPresenter onSubject: (objectSubjectFor: entry)) key: key
)
respondToAddForRoot = (
	openMenuWithLabelsAndActions: {
		{'Add Namespace'. [addNamespaceTemplate]}.
	}
)
respondToAddImage = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Image files (*.png)' ->'*.png'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key form |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		form:: PNGReadWriter formFromFileNamed: fn.
		subject namespace at: key asSymbol put: form.
	].
)
respondToAddText = (
	| fileRequester |
	fileRequester:: request File new.
	fileRequester allowedFileTypes: {'Text files (*.txt)' ->'*.txt'}.
	fileRequester initialDirectory: (FileDirectory default fullName).
	fileRequester openModal ifNotNil: [:fn |
		| key text |
		key:: (FileDirectory on: fn) localName allButLast: 4.
		key:: key select: [:letter | letter isAlphaNumeric].
		text:: ((MultiByteFileStream oldFileNamed: fn)
			converter: (TextConverter newForEncoding: 'utf8')) contents.
		subject namespace at: key asSymbol put: text.
	].
)
respondToCompileFile = (
   fileChooser chooseSingleFile: [:f | subject compileFile:  f
		ifSuccess:
			[updateGUI: []]
		ifFailure:
			[:msg | alert: msg]
		]
)
public tag ^ <String> = (
  ^title
)
public title = (
  ^subject key (*asText allBold*)
)
) : (
)
public class NamespaceSubject onModel: m <Map[Symbol, Object]> key: k <Symbol> = Subject onModel: m (|
	public key = k.
|ide namespacing refreshCategoryNamespaces) (
public = other ^<Boolean> = (
	^other isKindOfNamespaceSubject
		and: [namespace = other namespace
		and: [key = other key]].
)
public addClassFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| builder <ClassDeclarationBuilder> klass |
	[builder:: ClassDeclarationBuilder fromSource: definition]
		on: Error
		do: [:ex | ^failureBlock value: ex printString].
	(namespace includesKey: builder name) ifTrue:
		[^failureBlock value: 'A class named ', builder name, ' already exists in this namespace'].
	klass:: builder install applyToObject.
	namespace at: klass mixin name put: klass reflectee.
	successBlock value
)
public addNamespaceFromDefinition: definition <String> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
	| selector <Symbol> = definition asSymbol. |
	(*model = ide namespacing Categories ifFalse: (* ? *)
		[Error signal: 'Not supported yet, only categories for now.'].*)

	(*selector isUnary ifFalse:
		[^failureBlock value: 'Must be a unary selector'].*)
	(namespace includesKey: selector) ifTrue:
		[^failureBlock value: 'A class named ', definition, ' already exists in this namespace'].
	(* ide namespacing categoryNamespace: selector.*)
	namespace at: selector put: (ide namespacing freshNamespace).
	successBlock value
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment>  = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromClass: nil
		via: (colorizingBlockFor: cm)
)
public compileFile: f <Alien[File]> ifSuccess: successBlock <[]> ifFailure: failureBlock <[:String]> = (
  | p <Alien[Promise[String]]> = f text. |
  p then: [:s <String> | | builder <ClassDeclarationBuilder>  mirror <ClassDeclarationMirror> klass <Class> |
	builder:: [ClassDeclarationBuilder fromUnitSource: s] on: Error
		do: [:ex | ^failureBlock value: ex printString].
	klass:: builder install applyToObject.
	(namespace includesKey: klass mixin name) ifFalse: [
		namespace at: klass mixin name put: klass reflectee.
		].
	successBlock value
	]
)
public createPresenter ^ <NamespacePresenter> = (
	^NamespacePresenter onSubject: self
)
public hash ^<Integer> = (
	^model hash bitXor: key hash
)
public isKindOfNamespaceSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfNamespaceSubject
)
public namespace ^ <Map[Symbol, Object]> = (
	^self model
)
public refreshmentSubject = (
	^self class onModel: model key: key
)
public summaryText = (
	| sb = StringBuilder new. |
	namespace keys
		do: [:k | sb add: k]
		separatedBy: [sb add: ', '].
	^sb asString
)
public title ^<String> = (
	^key
)
) : (
public new = (
	#NAMESPACEBOGUS.
	^self onModel: ide namespacing Root key: 'Root'
)
)
class NestedClassGroupPresenter onSubject: s <Subject> = MirrorGroupPresenter onSubject: s (
(* Presents the subject, a NestedClassGroupSubject, as a column of presenters for the nested classes in the group. Automatically gets updated after the subject mirror group. Anything that has to do with adding, editing or deleting NS nested classes goes here. *)
) (
acceptNewClassDefinitionFrom: aTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	subject
		addClassFromDefinition: aTemplate text
		ifSuccess:
			[:newClass <ClassDeclarationMirror> |
			|
			newSubject <ClassSubject> = ClassSubject onModel: newClass.
			(*newPresenter <ClassEntryPresenter> = createPresenterForSubject: newSubject.*)
			|
			updateGUI: [
				prefixState removePrefix: aTemplate
				]
			]
		ifFailure:
			[:msg | aTemplate editor showMessage: msg]
)
public addNewItemTemplate = (
  | prefixState <DefinitionListPresenterState> = state. |
	(* Handle a user's request to create a new nested class by displaying a new class template. *)
	updateGUI: [ prefixState addPrefix:
		(DefinitionTemplate
			caption: 'Defining a new class:'
			initialText: subject classTemplateText
			colorizerBlock:
				[:text <String> :cm <CodeMIrrorFragment> | subject colorizeClassSource: text editor: cm]
			acceptResponse:
				[:template | acceptNewClassDefinitionFrom: template]
			cancelResponse:
				[:template | updateGUI: [prefixState removePrefix: template]]).
			]
)
public deleteClassInPresenter: presenter <Presenter> ifSuccess: successResponse <[]> ifFailure: failureResponse <[]> = (
	subject deleteClassWithSubject: presenter subject.
	successResponse value
)
elementPresenterClass ^ <ProgrammingPresenter class> = (
	^ClassEntryPresenter
)
public title = (
  ^'Classes'
)
) : (
)
public class NestedClassGroupSubject onModel: m <MirrorGroup[ClassDeclarationMirror]> within: dm <MixinMirror> = MirrorGroupSubject onModel: m within: dm  (
(* Represents the collection of nested classes of a Newspeak class. Holds onto the mirror group for the classes. *)
) (
public addClassFromDefinition: source <String> ifSuccess: successBlock <[:ClassDeclarationMirror]> ifFailure: failureBlock <[:String]> = (
	[ | builder <MixinBuilder> newBuilder <ClassDeclarationBuilder> newMirror <ClassDeclarationMirror> |
	builder:: definingMixin asBuilder.
	newBuilder:: builder nestedClasses addFromSource: source.
	builder declaration install.
	newMirror:: definingMixin nestedClasses findMirrorNamed: newBuilder name.
	successBlock value: newMirror]
		on: Error
		do: [:ex <Exception> | failureBlock value: ex printString].
)
public classTemplateText ^ <String> = (
^
'class ClassNameHere = (
	|
	slot1
	slot2
	|
) ()'
)
public colorizeClassSource: source <String> editor: cm <CodeMirrorFragment> = (
	^ide colorizer
		colorizeClassDeclaration: source
		fromClass: definingMixin declaration
		via: (colorizingBlockFor: cm)
)
public createPresenter = (
	^NestedClassGroupPresenter onSubject: self
)
public deleteClassWithSubject: classSubject <ClassSubject> = (
	| builder <MixinBuilder> |
	builder:: definingMixin asBuilder.
	builder nestedClasses removeMirrorNamed: classSubject name.
	builder declaration install.
)
elementSubjectClass ^ <ClassSubject class> = (
	^ClassSubject
)
public isKindOfNestedClassGroupSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfNestedClassGroupSubject
)
) : (
)
class ObjectPresenter onSubject: s = ProgrammingPresenter onSubject: s (
	|
	public selfCaption ::= 'self'.
	|
) (
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [respondToInspectMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
availableObjectViews = (
	subject isModelKindOfInteger ifTrue:
		[^{IntegerView onSubject: subject}].
	subject isModelKindOfString ifTrue:
		[^{StringView onSubject: subject}].

	subject isModelKindOfList ifTrue:
		[^{KeysAndValuesView title: 'List' onSubject: subject. BasicView onSubject: subject}].
	subject isModelKindOfMap ifTrue:
		[^{KeysAndValuesView title: 'Map' onSubject: subject. BasicView onSubject: subject}].

	^{BasicView onSubject: subject}
)
captionBar: body = (
	^(padded: body with: {5. 5. 5. 5}) color: captionColor
)
classInfoLine = (
	^row: {
		(label: 'class')
			width: 0 elasticity: 1.
		(link: subject className action: [navigateToClass])
			width: 0 elasticity: detailAreaRatio.
	}
)
public definition = (
	^column: {
		captionBar: (column: {
			selfInfoLine.
			enclosingInfoLine.
			classInfoLine.
			smallBlank.
			subject evaluator presenter.
		}).
		objectDetails.
	}
)
enclosingInfoLine = (
	^row: {
		(label: 'enclosingObject')
			width: 0 elasticity: 1.
		(link: subject enclosingObjectName action: [navigateToEnclosingObject])
			width: 0 elasticity: detailAreaRatio.
	}
)
public isKindOfObjectPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfObjectPresenter
)
navigateToClass = (
	enterSubject: subject classSubject.
)
navigateToEnclosingObject = (
	inspectObjectMirror: subject classMirror enclosingObject
)
navigateToSelf = (
	enterSubject: subject
)
objectDetails = (
	| views = availableObjectViews. currentView switchers |
	views size = 1 ifTrue: [^views first].
	currentView:: holder: views first.
	switchers:: List new.
	views do:
		[:view |
		 switchers add: mediumBlank.
		 switchers add: ((link: '[', view title, ']' action: [currentView content: view]) color: actionLinkColor)].
	^column: {
		row: switchers.
		currentView.
	}
)
respondToInspectMirror = (
	inspectObject: subject objectMirror.
)
selfInfoLine = (
	^row: {
		(label: selfCaption (*asText allBold*)) width: 0 elasticity: 1.
		(row: {
			(link: subject title action: [navigateToSelf]) compressibility: 1.
			filler compressibility: 0.
			mediumBlank.
			dropDownMenu: [actionsMenu].
			mediumBlank.
			homeButton.
		}) width: 0 elasticity: detailAreaRatio.
	}
)
public title = (
	^'Inspector on ', subject title
)
) : (
)
public class ObjectSubject onModel: m = Subject onModel: m (
  | 
  public evaluator <EvaluationViewState> = EvaluationViewState onModel: self. 
  slotMap <Map[Symbol, SlotSubject]> ::= Map new.
  |
) (
public = another <Object> ^<Boolean> = (
	^(another isKindOfObjectSubject) and:
		[objectMirror = another objectMirror]
)
arraySlotSubjectFor: index <Integer> value: val <ObjectMirror> = (
  | name = 'at:', index asString. |
  ^slotMap at: name ifAbsent: [
	SlotSubject name: name value: val
	]
)
public classMirror ^<ClassMirror> = (
	^model getClass
)
public className ^<String> = (
	^classMirror mixin name
)
public classSubject = (
	^ClassSubject onModel: classMirror mixin declaration
)
computeArraySlots = (
  | 
  array = objectMirror reflectee.
  variableLengthSlots = Array new: array size.
  newMap <Map[Symbol, SlotSubject]> = Map new.
  |
  1 to: array size do: [:index | | slot |
	      slot:: arraySlotSubjectFor: index value: (ObjectMirror reflecting: (array at: index)).
	      newMap at: slot name put: slot.
		variableLengthSlots at: index put: slot
		].
				
  slotMap:: newMap.
  ^variableLengthSlots
)
computeSlots = (
  | 
  newMap <Map[Symbol, SlotSubject]> = Map new.
  slotList<List[SlotSubject]> =   classMirror slots collect: [:slot <SlotDeclarationMirror> |  
	newMap at: slot name put: (slotSubjectFor: slot)
	].
  |
  slotMap:: newMap.
  ^slotList
)
public createPresenter = (
	^ObjectPresenter onSubject: self
)
public enclosingObjectName = (
	^classMirror enclosingObject reflectee printString
)
public evaluate: expression <String> ^<ThreadMirror> = (
	(* The IDE provides ambient access to the platform object during development. *)
	| scope <Map[Symbol, ObjectMirror]> = Map new. |
	scope at: #_ put: (ObjectMirror reflecting: cachedPlatform).
	^objectMirror evaluate: expression with: scope
)
public hash ^<Integer> = (
	^self class hash bitXor: objectMirror hash
)
public isKindOfObjectSubject = (
  ^true
)
public isModelKindOfArray ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: Array)
)
public isModelKindOfInteger ^<Boolean> = (
	^objectMirror reflectee isKindOfInteger
)
public isModelKindOfList ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: List)
)
public isModelKindOfMap ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: Map)
)
public isModelKindOfString ^<Boolean> = (
	^classMirror = (ClassMirror reflecting: String)
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfObjectSubject
)
public keysAndValues ^<Collection[SlotSubject]> = (
	| result |
	result:: List new: objectMirror reflectee size.
	objectMirror reflectee keysAndValuesDo:
		[:key :value | result add:
			(SlotSubject
				name: 'at: ', key printString
				value: (ObjectMirror reflecting: value))].	
	^result
)
public objectMirror ^<ObjectMIrror> = (
	^model
)
public resetPresenters = (
  super resetPresenters.
  slotMap do: [:s <SlotSubject> | s resetPresenters].
  evaluator resetPresenters.
)
slotSubjectFor: slot <SlotDeclarationMirror> = (
  ^slotMap at: slot name ifAbsent: [
      | val <ObjectMirror> = objectMirror getSlot: slot name. |
	SlotSubject name: slot name value: val
	]
)
public slots ^ <Sequence[SlotSubject]> = (
	(* Arrays have slots that aren't defined by their class. *)
	(* :todo: Push this down to `ObjectMirror slots` because which classes this applies to is implementation specific. *)
	isModelKindOfArray ifTrue:
		[^computeArraySlots].
      ^computeSlots.
)
public title = (
	^objectMirror reflectee printString
)
) : (
)
public class ProgrammingPresenter onSubject: s <Subject> = Presenter onSubject: s (
(* Common superclass for presenters of programming constructs. *)
) (
actionLinkColor = (
	^Color black
)
addButtonWithAction: aBlock = (
	^imageButton:
		{ide images addImage.
		ide images addOverImage.
		ide images addOutImage}
	action: aBlock
)
addButtonWithMenu: menu = (
	^dropDownMenu: menu
		images: {
		   ide images addImage.
		   ide images addOverImage.
		   ide images addOutImage
		}
)
browseClass: klass <Behavior> = (
	enterSubject:: ClassSubject onModel: (ClassMirror reflecting: klass) mixin declaration.
)
browseMixinMirror: mixin <MixinMirror> = (
	enterSubject:: ClassSubject onModel: mixin declaration.
)
collapseButtonWithAction: aBlock = (
	^imageButton:
		{ide images collapseImage.
		 ide images collapseOverImage.
		 ide images collapseDownImage}
	action: aBlock
)
expandButtonWithAction: aBlock = (
	^imageButton:
		{ide images expandImage.
		 ide images expandOverImage.
		 ide images expandDownImage}
	action: aBlock
)
homeButton = (
	^imageButton: {
		ide images homeImage.
		ide images homeOutImage.
		ide images homeOverImage.
		ide images homeDownImage
		}
		action: [enterSubject: (HomeViewSubject onModel: HomeSubject new)].
)
iconForAccessModifier: am = (
	#private = am ifTrue: [^ide images privateAccessImage].
	#protected = am ifTrue: [^ide images protectedAccessImage].
	^ide images publicAccessImage
)
indentedBlock: body = (
	^column: {
		mediumBlank.
		row: {
			mediumBlank.
			elastic: body
			}.
		mediumBlank
		}
)
inspectObject: object <Object> = (
	enterSubject:: ObjectSubject onModel: (ObjectMirror reflecting: object).
)
inspectObjectMirror: object <ObjectMirror> = (
	enterSubject:: ObjectSubject onModel: object.
)
largeBlank = (
	^blank: 20
)
majorHeadingBlock: body = (
	^(padded: body with: {10. 10. 10. 10.})
		color: majorHeadingColor
)
majorHeadingColor = (
	(* This color is used for major definitions such as class headings. *)
	^Gradient
		from: (Color h: 240 s: 0.05 v: 0.92)
		to: (Color h: 240 s: 0.05 v: 0.86)
)
minorHeadingBlock: body = (
	^(padded: body with: {10. 5. 10. 5.})
		color: minorHeadingColor
)
minorHeadingColor = (
^Gradient
	from: (Color h: 240 s: 0.02 v: 0.94)
	to: (Color h: 240 s: 0.02 v: 0.9)
)
public objectSubjectFor: anObject = (
	^objectSubjectForMirror: (ObjectMirror reflecting: anObject)
)
objectSubjectForMirror: objectMirror <ObjectMirror> = (
	^ObjectSubject onModel: objectMirror
)
refreshButton = (
	^imageButton: {
		ide images refreshImage.
		ide images refreshOutImage.
		ide images refreshOverImage.
		ide images refreshDownImage
		}
		action: [shell refresh].
)
respondToInspectPresenter = (
	inspectObject: self.
)
secondaryTextColor ^ <Color> = (
	^Color gray: 0.6
)
smallBlank = (
	^blank: 5
)
tertiaryTextColor = (
	^Color gray: 0.8
)
) : (
)
class SlotPresenter onSubject: s <SlotSubject> = ProgrammingPresenter onSubject: s (
) (
caption ^<Fragment> = (
	^row: {
		(link: subject name action: [substance toggle])
			width: 0 elasticity: 1;
			color: actionLinkColor.
		smallBlank.
		(link: subject reflecteePrintString action: [inspectObjectMirror: subject objectMirror])
			width: 0 elasticity: detailAreaRatio.
	}
)
public definition ^<Fragment> = (
	^collapsed: [caption] expanded: [details]
)
details ^<Fragment> = (
	^subject objectSubject presenter selfCaption: subject name
)
public isKindOfSlotPresenter ^ <Boolean> = (
  ^true
)
isMyKind: f <Fragment> ^ <Boolean> = (
  ^f isKindOfSlotPresenter
)
) : (
)
public class SlotSubject name: n value: v = Subject onModel: v (
	|
	public name = n.
	public objectSubject <ObjectSubject> = ObjectSubject onModel: objectMirror.
	|
) (
public = other <Object> ^ <Boolean> = (
  other isKindOfSlotPresenter ifFalse: [^false].
  ^model = other model and: [name = other name].
)
public createPresenter = (
	^SlotPresenter onSubject: self
)
public hash ^ <Integer> = (
  ^model hash xor: name hash
)
public isKindOfSlotSubject ^ <Boolean> = (
  ^true
)
isMyKind: s <Subject> ^ <Boolean> = (
  ^s isKindOfSlotSubject
)
public objectMirror ^<ObjectMirror> = (
	^model
)
public reflecteePrintString = (
	^model reflectee printString
)
public resetPresenters = (
  super resetPresenters.
  objectSubject resetPresenters.
)
) : (
)
class StringView onSubject: s = ProgrammingPresenter onSubject: s (
) (
public definition = (
	| cm |
	cm:: codeMirror: subject objectMirror reflectee.
	cm readOnly: true.
	^column: {
		cm
	}
)
public isKindOfStringView ^ <Boolean> = (
  ^true
)
isMyKind: other <Fragment> ^ <Boolean> = (
  ^other isKindOfStringView
)
) : (
)
colorizingBlockFor: cm <CodeMirrorFragment> = (
	^[:r | | style <Alien[JSObject]> = JSObject new. |
	style at: 'css' put: (cssFor: r kind).
	cm style: style from: r start to: r end]
)
crToLf: string = (
	('a' at: 1) isKindOfInteger
		ifTrue:
			[ | bytes = ByteArray withAll: string. |
			1 to: bytes size do: [:index | (bytes at: index) = 13 ifTrue: [bytes at: index put: 10]].
			^bytes asString]
		ifFalse:
			[ | cr = String fromRune: 13. lf = String fromRune: 10. |
			^string replaceAll: cr with: lf]
)
cssConversionTable ^ <Map[Symbol, String]> = (
(* compute a mapping from 'kinds', which are symbols denoting logical categories of code, to CSS properties used to colorize them*)
	|
	redBoldUnderlined <String> = 'color:Red; font-weight:bold; text-decoration: underline'.
	redUnderlined <String> = 'color:Red; text-decoration: underline'.
	orangeBoldUnderlined <String> = 'color:Orange; font-weight:bold; text-decoration: underline'.
	underlined <String> = 'text-decoration: underline'.
	gray <String> = 'color:Gray'.
	blue <String> = 'color:Blue'.
	grayBold <String> = 'color:Gray; font-weight:bold'.
	blackBold <String> = 'color:Black; font-weight:bold'.
	blueBold <String> = 'color:Blue; font-weight:bold'.
	magentaBold <String> = 'color:Magenta; font-weight:bold'.
	bold <String> = 'font-weight:bold'.
	|
      ^Map new
		at: #error put: redBoldUnderlined;
		at: #undefinedUnary put: redUnderlined;
		at: #undefinedBinary put: redUnderlined;
		at: #undefinedKeyword put: redUnderlined;
		at: #shadowingTempVar put: orangeBoldUnderlined;
		at: #obsoleteMessage put: orangeBoldUnderlined;
		at: #whitespaceWarning put: orangeBoldUnderlined;
		at: #incompleteUnary put: underlined;
		at: #incompleteBinary put: underlined;
		at: #incompleteKeyword put: underlined;
		at: #self put: gray;
		at: #super put: gray;
		at: #outer put: gray;
		at: #true put: gray;
		at: #false put: gray;
		at: #nil put: gray;
		at: #string put: gray;
		at: #symbol put: gray;
		at: #number put: gray;
		at: #character put: gray;
		at: #public put: gray;
		at: #protected put: gray;
		at: #private put: gray;
		at: #tempVar put: grayBold;
		at: #blockTempVar put: grayBold;
		at: #blockPatternArg put: grayBold;
		at: #patternArg put: grayBold;
		at: #slotDecl put: grayBold;
		at: #patternTempVar put: grayBold;
		at: #methodTempBar put: blackBold;
		at: #leftParenthesis put: blackBold;
		at: #rightParenthesis put: blackBold;
		at: #leftParenthesis3 put: blackBold;
		at: #rightParenthesis3 put: blackBold;
		at: #leftParenthesis6 put: blackBold;
		at: #rightParenthesis6 put: blackBold;
		at: #blockStart put: blackBold;
		at: #blockEnd put: blackBold;
		at: #blockStart3 put: blackBold;
		at: #blockEnd3 put: blackBold;
		at: #blockStart6 put: blackBold;
		at: #blockEnd6 put: blackBold;
		at: #leftBrace put: blackBold;
		at: #rightBrace put: blackBold;
		at: #leftBrace3 put: blackBold;
		at: #rightBrace3 put: blackBold;
		at: #leftBrace6 put: blackBold;
		at: #rightBrace6 put: blackBold;
		at: #messagePatternDecl put: bold;
		at: #class put: gray;
		at: #className put: bold;
		at: #comment put: blue;
		at: #type put: blueBold;
		at: #return put: blueBold;
		at: #leftParenthesis1 put: blueBold;
		at: #rightParenthesis1 put: blueBold;
		at: #leftParenthesis4 put: blueBold;
		at: #rightParenthesis4 put: blueBold;
		at: #leftParenthesis7 put: blueBold;
		at: #rightParenthesis7 put: blueBold;
		at: #blockStart1 put: blueBold;
		at: #blockEnd1 put: blueBold;
		at: #blockStart4 put: blueBold;
		at: #blockEnd4 put: blueBold;
		at: #blockStart7 put: blueBold;
		at: #blockEnd7 put: blueBold;
		at: #leftBrace1 put: blueBold;
		at: #rightBrace1 put: blueBold;
		at: #leftBrace4 put: blueBold;
		at: #rightBrace4 put: blueBold;
		at: #leftBrace7 put: blueBold;
		at: #rightBrace7 put: blueBold;
		at: #leftParenthesis2 put: magentaBold;
		at: #rightParenthesis2 put: magentaBold;
		at: #leftParenthesis5 put: magentaBold;
		at: #rightParenthesis5 put: magentaBold;
		at: #blockStart2 put: magentaBold;
		at: #blockEnd2 put: magentaBold;
		at: #blockStart5 put: magentaBold;
		at: #blockEnd5 put: magentaBold;
		at: #leftBrace2 put: magentaBold;
		at: #rightBrace2 put: magentaBold;
		at: #leftBrace5 put: magentaBold;
		at: #rightBrace5 put: magentaBold;
		yourself
)
cssFor: k <Symbol> ^ <String> = (
        ^cssConverter at: k ifAbsent: [ 'color:Black; font-family: TimesNewRoman']
)
) : (
)
