Newspeak3
'HopscotchIDE'
class Debugging2 usingPlatform: platform ide: ide = (
	(* UI for the Web debugger. *)
	|
	private List = platform collections List.

	private Color = platform graphics Color.

	private Gradient = platform hopscotch Gradient.
	private Subject = platform hopscotch Subject.
	private TextEditorFragment = platform hopscotch TextEditorFragment.

	private EvaluationPresenter = ide browsing EvaluationPresenter.
	private ProgrammingPresenter = ide browsing ProgrammingPresenter.
	private SlotSubject = ide browsing SlotSubject.
	|
) (
class ActivationPresenter onSubject: s <ThreadSubject> = ProgrammingPresenter onSubject: s (
) (
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [respondToInspectMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
public collapse = (
	substance collapse.
)
public definition ^ <Fragment> = (
	^collapsed: [definitionForHeader] expanded: [column: {
		definitionForHeader.
		definitionForControls.
		row: {
			definitionForSource width: 0 elasticity: 1.6 asFloat.
			smallBlank.
			definitionForState width: 0 elasticity: 1.
		}.
	}]
)
definitionForControls = (
	^row: {
		button: 'restart' action: [respondToRestart].
		smallBlank.
		button: 'over' action: [respondToStepOver].
		smallBlank.
		button: 'into' action: [respondToStepInto].
		smallBlank.
		button: 'into closure' action: [respondToStepIntoClosure].
		smallBlank.
		button: 'out' action: [respondToStepOut].
		filler.
		button: '^self' action: [respondToReturnSelf].
		smallBlank.
		button: '^nil' action: [respondToReturnNil].
		smallBlank.
		button: '^false' action: [respondToReturnFalse].
		smallBlank.
		button: '^true' action: [respondToReturnTrue].
		smallBlank.
	}
)
definitionForHeader = (
	| qualification |
	qualification:: subject receiverMixin = subject methodMixin
		ifTrue:
			[{}]
		ifFalse:
			[{
				(label: ' ( ')
					color: tertiaryTextColor.
				(link: subject methodMixin name action: [browseMixinMirror: subject methodMixin])
					color: secondaryTextColor.
				(label: ' )')
					color: tertiaryTextColor.
			}].

	^row: {
		(link: subject name action: [substance toggle])
			color: actionLinkColor.
		(label: ' in ')
			color: tertiaryTextColor.
		(link: subject receiverMixin name action: [browseMixinMirror: subject receiverMixin])
			color: secondaryTextColor.
	} , qualification , {
		filler.
		dropDownMenu: [actionsMenu].
	}
)
definitionForSource = (
	^TextEditorFragment new
		text: subject source
)
definitionForState = (
	| slotPresenters = List new. |
	subject slotsDo:
		[:slot <LocalSubject> | slotPresenters add: slot presenter].
	^column: {
		EvaluationPresenter onSubject: subject.
		list: slotPresenters
	}
)
public expand = (
	substance expand.
)
respondToInspectMirror = (
	inspectObject: subject activationMirror.
)
respondToRestart = (
)
respondToReturnFalse = (
)
respondToReturnNil = (
)
respondToReturnSelf = (
)
respondToReturnTrue = (
)
respondToStepInto = (
)
respondToStepIntoClosure = (
)
respondToStepOut = (
)
respondToStepOver = (
)
) : (
)
class ActivationSubject onModel: m <ActivationMirror> in: t <ThreadSubject> = Subject onModel: m (
|
	protected threadSubject <ThreadSubject> = t.
|
) (
public = other <Object> ^<Boolean> = (
	other isKindOfActivationSubject ifFalse: [^false].
	^model = other model
)
public activationMirror ^<ActivationMirror> = (
	^model
)
public className = (
	^nil
)
public createPresenter = (
	^ActivationPresenter onSubject: self
)
public evaluate: expression <String> ^<ThreadMirror> = (
	^model evaluate: expression
)
public isKindOfActivationSubject ^<Boolean> = (
	^true
)
public methodMixin ^<MixinMirror> = (
	^model method definingMixin
)
public name ^<String> = (
	| n enclosing |
	n:: model method name.
	enclosing:: model enclosingActivation.
	[nil = enclosing] whileFalse:
		[n:: '[] in ', n.
		 enclosing:: enclosing enclosingActivation].
	^n
)
public receiverMixin ^<MixinMirror> = (
	^model receiver getClass mixin
)
public slotsDo: action <[:SlotSubject]> = (
	action value: (SlotSubject name: 'self' value: model receiver).
	model slots do:
		[:local | action value: (SlotSubject name: local name value: local value)].
)
public source ^<String> = (
	| s = model method source. |
	nil = s ifTrue: [^'<source unavailable>'].
	^s
)
public title ^<String> = (
	^name , ' in ' , receiverMixin name , '(', methodMixin name , ')'.
)
) : (
)
class ThreadPresenter onSubject: s <ThreadSubject> = ProgrammingPresenter onSubject: s (
	|
	activations <PresenterList>
	|
) (
actionsMenu = (
	^menuWithLabelsAndActions: {
		{'Inspect Mirror'. [respondToInspectMirror]}.
		{'Inspect Presenter'. [respondToInspectPresenter]}.
	}
)
definition = (
	^column: {
		mainHeadingBlock: (column: {
			row: {
				(label: 'Thread: ', subject stateName) color: Color white.
				filler.
				dropDownMenu: [actionsMenu].
			}.
			mediumBlank.
			row: {
				filler.
				button: 'Continue' action: [respondToContinue].
				largeBlank.
				button: 'Terminate' action: [respondToTerminate].
				filler.
			}.
		}).
		smallBlank.
		minorHeadingBlock: (row: {
			label: 'Activations'.
			filler.
			expandButtonWithAction: [respondToExpandAll].
			blank: 3.
			collapseButtonWithAction: [respondToCollapseAll].
		}).
		smallBlank.
		definitionForActivationsList.
		largeBlank.
	}
)
definitionForActivationsList = (
	| activationPresenters = List new. |
	subject activationsDo:
		[:activation <ActivationSubject> | activationPresenters add: (activation presenter)].
	^activations:: list: activationPresenters
)
mainHeadingBlock: body = (
	^(padded: body with: {10. 10. 10. 10.})
		color: (Gradient from: (Color h: 0 s: 0.5 v: 0.8) to: (Color h: 0 s: 0.5 v: 0.6))
)
respondToCollapseAll = (
	activations presenters do: [:activation <ActivationPresenter> | activation collapse].
)
respondToContinue = (
)
respondToExpandAll = (
	activations presenters do: [:activation <ActivationPresenter> | activation expand].
)
respondToInspectMirror = (
	inspectObject: subject threadMirror.
)
respondToTerminate = (
)
) : (
)
public class ThreadSubject onModel: m <ThreadMirror> = Subject onModel: m (
) (
public = other <Object> ^<Boolean> = (
	other isKindOfThreadSubject ifFalse: [^false].
	^model = other model
)
public activationsDo: action <[:ActivationSubject]> = (
	| activation <ActivationMirror> |
	activation:: model suspendedActivation.
	[nil = activation] whileFalse:
		[action value: (ActivationSubject onModel: activation in: self).
		activation:: activation sender].
)
public createPresenter = (
	^ThreadPresenter onSubject: self
)
public isKindOfThreadSubject ^<Boolean> = (
	^true
)
public stateName ^<String> = (
	model isFulfilled ifTrue: [^'Fulfilled'].
	model isBroken ifTrue: [^'Broken'].
	model isSuspended ifTrue: [^'Suspended'].
	^'Unknown'
)
public threadMirror ^<ThreadMirror> = (
	^model
)
) : (
)
) : (
)
